<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-symlinks">
  <?dbhtml filename="symlinks.html"?>

  <title>Управление устройствами</title>

  <sect2 revision="sysv">

    <title>Cетевое оборудование</title>

    <para>Udev по умолчанию называет сетевые устройства в соответствии с данными прошивки, BIOS или физическими характеристиками, такими как шина, слот или MAC-адрес. Цель такого соглашения о именовании нужна для гарантии того, что сетевые устройства названы последовательно и не на основывались на времени обнаружении усстройства. Например, на компьютере с двумя сетевыми картами производства Intel и Realtek сетевая карта производства Intel может стать eth0, а карта Realtek-eth1. В некоторых случаях после перезагрузки, сетевые карты могут быть переименованы в другой последовательности.</para>

    <para>В новой схеме именования обычные имена сетевых устройств будут чем-то вроде enp5s0 или wlp3s0. Если это соглашение о именовании не требуется, традиционная схема или своя собственная, может быть использована.</para>

    <sect3>
      <title>Отключение постоянного именования в командной строке ядра</title>

      <para>Традиционная схема именования - eth0, eth1, и так далее, могут быть установлены путем добавления <userinput>net.ifnames=0</userinput> в командную строку ядра. Это подойдёт для систем, которые имеют только сетевое устройство одного типа. В ноутбуках часто есть несколько сетевых соединений с именами eth0 и wlan0. Эта схема вполне применима к ним. Командная строка передается в файле конфигурации GRUB. См. <xref linkend="grub-cfg"/>.</para>
    </sect3>

    <sect3>
      <title>Создание собственных правил Udev</title>

      <para>Именование схемы может быть настроено, созданием собственных правил Udev. Существует файл сценария, который генерирует начальные правила. Чтобы их сгенерировать, выполните команду:</para>

		<screen role="install"><userinput>bash /lib/udev/init-net-rules.sh</userinput></screen>

      <para>Теперь, проверьте файл <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>, и найдите в нём данные о том, какое название с каким сетевым устройством сопоставлено:</para>

<screen role="nodump"><userinput>cat /etc/udev/rules.d/70-persistent-net.rules</userinput></screen>

      <note><para>В некоторых случаях, например, когда MAC-адреса были назначены
      сетевой карте вручную или в виртуальной среде, такой как Qemu или Xen,
      возможно, файл сетевых правил не будет создан, поскольку адреса
      не назначаются последовательно.  В этих случаях, этот способ не применим.</para></note>

      <para>Файл начинается с блока комментариев, далее следуют две строки для каждой сетевой карты (NIC). Первая строка, в блоке комментария - это  её описание, аппаратные идентификаторы (например, поставщик PCI и идентификаторы устройств, если это PCI-карта),  вместе со своим драйвером в скобках, если драйвер удаётся найти. Никакой идентификатор оборудования и драйвер не используются для определения имени интерфейса. Эта информация только для справки. Вторая строка -
      правило Udev, которое соответствует сетевой карте и фактически присваивает ему имя.</para>

      <para>Все правила udev состоят из нескольких ключей, разделенных запятыми и необязательными пробелами. Ключи правила и объяснение каждого из них:</para>

      <itemizedlist>
        <listitem>
          <para><literal>SUBSYSTEM=="net"</literal> - сообщает Udev игнорировать устройства, которые не явлвяются сетевыми картами.</para>
        </listitem>
        <listitem>
          <para><literal>ACTION=="add"</literal> - сообщает Udev игнорировать это правило для события uevent которое не добавляет (события uevents "удалить" и "добавить" также произойдут, но без необходимости переименования сетевого интерфейса).</para>
        </listitem>
        <listitem>
          <para><literal>DRIVERS=="?*"</literal> - Это сделано так, чтобы Udev проигнорировал подинтерфейсы VLAN или моста (потому что эти подинтерфейсы не имеют драйверов). Эти подинтерфейсы пропускаются, поскольку имя, которое было бы назначено, столкнулось бы с их родительскими устройствами.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{address}</literal> - Значение этого ключа - является MAC адресом сетевой карты.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{type}=="1"</literal> - Это гарантирует, что правило только совпадает с основным интерфейсом в случае определенных беспроводных драйверов, которые создают множественные виртуальные интерфейсы. Вторичные интерфейсы пропущены по той же причине, что VLAN и подинтерфейсы моста. В ином случае будет конфликт имен.</para>
        </listitem>
        <listitem>
          <para><literal>NAME</literal> - Значение этого ключа  - наименование сетевого интерфейса, назначенного Udev.</para>
        </listitem>
      </itemizedlist>

      <para>Значение <literal>NAME</literal> является важным. Прежде чем продолжить, убедитесь, что вы знаете, какое имя назначено каждой из сетевых карт, и не забудьте использовать это имя при создании файлов конфигурации ниже.</para>

    </sect3>

  </sect2>

  <sect2 revision="sysv">

    <title>Символические ссылки CD-ROM</title>

    <para>Некоторые программы, которые вы захотите установить позднее (например, различные медиа-проигрыватели), ожидают, устройства <filename class="symlink">/dev/cdrom</filename> и <filename class="symlink">/dev/dvd</filename> и символические ссылки на CD-ROM или DVD-ROM устройства. Кроме того, может быть удобно поместить ссылки на эти символические ссылки в <filename>/etc/fstab</filename>. Udev поставляется со файлом сценария, который будет генерировать файлы правил для создания этих символических ссылок для вас, в зависимости от возможностей каждого устройства, но вам нужно решить, какой из двух режимов работы вы хотите использовать.</para>

    <para>Во-первых, скрипт может работать в режиме <quote>by-path</quote> (используется по умолчанию для USB и FireWire устройств), где создаваемые им правила зависят от физического пути к CD или DVD устройству. Во-вторых, он может работать в режиме <quote>by-id</quote> (по умолчанию для устройств IDE и SCSI), где создаваемые им правила зависят от строк идентификации, хранящихся в самом устройстве CD или DVD. Путь определяется сценарием Udev <command>path_id</command>, а идентификационные строки считываются с оборудования программами <command>ata_id</command> или <command>scsi_id</command>, в зависимости от того, какой тип устройства у вас есть.</para>

    <para>У каждого подхода есть свои преимущества; правильный подход к использованию будет зависеть от того, какие изменения устройств могут произойти. Если вы ожидаете, что физический путь к устройству (порты и/или слоты, которые он подключает), изменится, например, потому, что вы планируете переместить диск в другой порт IDE или другой разъем USB, то вы должны использовать режим <quote>by-id</quote>. С другой стороны, если вы ожидаете, что идентификация устройства изменится, например, потому, что оно может умереть, и вы замените его другим устройством с теми же возможностями и которое подключено к тем же разъемам, тогда вы должны использовать режим <quote>by-path</quote>.</para>

    <para>Если с вашим устройством возможен любой из вариантов, выберите тот, который случается наиболее часто.</para>

<!-- If you use by-id mode, the symlinks will survive even the transition
     to libata for IDE drives, but that is not for the book. -->

    <important><para>Внешние устройства (например, компакт-диск, подключенный через USB) не следует использовать методом <quote>by-path</quote>, потому что каждый раз, когда устройство подключено в новый внешний порт, изменится его физический путь. Все внешние устройства подвержены этой проблеме при написании правил Udev при
    распознавании их по их физическому пути. К тому же, эта проблема не ограничивается CD и DVD-дисками.</para></important>

    <para>Если вы хотите увидеть значения, которые будут использоваться сценариями Udev, то для соответствующего устройства CD-ROM найдите в  каталоге <filename class="directory">/sys</filename> (например, это может быть каталог <filename class="directory">/sys/block/hdd</filename>) и выполните команду, наподобие следующей:</para>

<screen role="nodump"><userinput>udevadm test /sys/block/hdd</userinput></screen>

    <para>Обратите внимание на строки, содержащие вывод различных программ *_id. Режим <quote>by-id</quote> будет использовать значение ID_SERIAL если оно существует и не пустое, иначе будет использована комбинация ID_MODEL и ID_REVISION. Режим <quote>by-path</quote> будет использовать значение ID_PATH.</para>

    <para>Если режим по умолчанию не подходит для Вашей ситуации, то в файле <filename>/etc/udev/rules.d/83-cdrom-symlinks.rules</filename>
    можно сделать изменение следующим образом (где <replaceable>mode</replaceable> один из <quote>by-id</quote> или <quote>by-path</quote>):</para>

	<screen role="nodump"><userinput>sed -i -e 's/"write_cd_rules"/"write_cd_rules <replaceable>mode</replaceable>"/' \
    /etc/udev/rules.d/83-cdrom-symlinks.rules</userinput></screen>

    <para>Обратите внимание, что на данный момент, нет необходимости создавать файлы правил или символические ссылки, так как вы смонтировали каталог <filename class="directory">/dev</filename> хост системы в системе LFS, и мы предполагаем, что символические ссылки уже существуют. Правила и символические ссылки будут созданы при первой загрузке LFS системы.</para>

    <para>Однако, если у вас есть несколько устройств CD-ROM, то символические ссылки, сгенерированные в то время, могут указывать на другие устройства, и иметь различия от хост системы, потому что устройства не будут обнаружены в предсказуемом порядке. Назначения, созданные при первой загрузке системы LFS, будут стабильными, поэтому проблема возникает только в том случае, если символические ссылки в обеих системах указывают на одно и то же устройство. Если потребуется, проверьте (и, возможно, отредактируйте) сгенерированные правила в файле <filename>/etc/udev/rules.d/70-persistent-cd.rules</filename> после загрузки, чтобы убедиться, что назначенные символические ссылки соответствуют.</para>

  </sect2>

  <sect2>

    <title>Работа с дублирующими устройствами</title>

    <para>Как поясняется в <xref linkend="ch-scripts-udev"/>, порядок отображения устройства с одинаковой функциональностью в <filename class="directory">/dev</filename> является, как правило, случайным. Например, если у вас есть веб камера и TV тюнер, иногда <filename>/dev/video0</filename> ссылается на камеру а <filename>/dev/video1</filename> ссылается на TV тюнер, а иногда, например, после перезагрузки системы, порядок поменяется на противоположный. Для всех классов оборудования, кроме звуковых и сетевых карт, это поправимо, путем создания пользовательских постоянных ссылкок udev. Случай относительно сетевых карт рассказаны отдельно в <xref linkend="ch-scripts-network"/>, и инструкции по конфигурированию звуковых карт можно найти в <ulink url="&blfs-book;postlfs/devices.html">BLFS</ulink>.</para>

    <para>Для каждого из ваших устройств, которые могут иметь такую проблему (даже если проблема не существует в текущем дистрибутиве Linux ),
    найдите соответствующий каталог в
    <filename class="directory">/sys/class</filename> или
    <filename class="directory">/sys/block</filename>.
	 Для видео устройств, это могут быть каталоги
    <filename
    class="directory">/sys/class/video4linux/video<replaceable>X</replaceable></filename>. Выясните атрибуты, которые идентифицируют устройство однозначно (обычно,
    это идентификаторы поставщика и продукта и / или серийные номера):</para>

	<screen role="nodump"><userinput>udevadm info -a -p /sys/class/video4linux/video0</userinput></screen>

   <para>Затем, напишите правило, которое создаёт символические ссылки. Например:</para>

<screen role="nodump"><userinput>cat &gt; /etc/udev/rules.d/83-duplicate_devs.rules &lt;&lt; "EOF"
<literal>
# Persistent symlinks for webcam and tuner
KERNEL=="video*", ATTRS{idProduct}=="1910", ATTRS{idVendor}=="0d81", \
    SYMLINK+="webcam"
KERNEL=="video*", ATTRS{device}=="0x036f", ATTRS{vendor}=="0x109e", \
    SYMLINK+="tvtuner"
</literal>
EOF</userinput></screen>

    <para>В результате устройства <filename>/dev/video0</filename> и <filename>/dev/video1</filename> по-прежнему случайным образом ссылаются на TV тюнер и веб-камеру (и, следовательно, никогда не должны использоваться напрямую), но есть символические ссылки /dev/tvtuner и /dev/webcam, которые всегда указывают на правильное устройство.</para>

 </sect2>

</sect1>
